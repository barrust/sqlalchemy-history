{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLAlchemy-History SQLAlchemy-history is a fork of sqlalchemy-continuum. An auditing extension for sqlalchemy which keeps a track of the history of your sqlalchemy models Features Supports sqlalchemy 1.4+ and python 3.7+ Tracks history for inserts, deletes, and updates Does not store updates which don't change anything Supports alembic migrations Can revert objects data as well as all object relations at given transaction even if the object was deleted Transactions can be queried afterwards using SQLAlchemy query syntax Query for changed records at given transaction Temporal relationship reflection. Get the relationships of an object in that point in time. QuickStart pip install sqlalchemy-history In order to make your models versioned you need two things: Call make_versioned() before your models are defined. Add __versioned__ to all models you wish to add versioning to >>> from sqlalchemy_history import make_versioned >>> make_versioned(user_cls=None) >>> class Article(Base): ... __versioned__ = {} ... __tablename__ = 'article' ... id = sa.Column(sa.Integer, primary_key=True, autoincrement=True) ... name = sa.Column(sa.Unicode(255)) ... content = sa.Column(sa.UnicodeText) >>> article = Article(name='Some article', content='Some content') >>> session.add(article) >>> session.commit() 'article has now one version stored in database' >>> article.versions[0].name 'Some article' >>> article.name = 'Updated name' >>> session.commit() >>> article.versions[1].name 'Updated name' >>> article.versions[0].revert() 'lets revert back to first version' >>> article.name 'Some article' For completeness, below is a working example. from sqlalchemy_history import make_versioned from sqlalchemy import Column, Integer, Unicode, UnicodeText, create_engine try: from sqlalchemy.ext.declarative import declarative_base except ImportError: # sqla > 2.x from sqlalchemy.orm import declarative_base from sqlalchemy.orm import create_session, configure_mappers make_versioned(user_cls=None) Base = declarative_base() class Article(Base): __versioned__ = {} __tablename__ = 'article' id = Column(Integer, primary_key=True, autoincrement=True) name = Column(Unicode(255)) content = Column(UnicodeText) configure_mappers() engine = create_engine('sqlite://') Base.metadata.create_all(engine) session = create_session(bind=engine, autocommit=False) article = Article(name='Some article', content='Some content') session.add(article) session.commit() print(article.versions[0].name) # 'Some article' article.name = 'Updated name' session.commit() print(article.versions[1].name) # 'Updated name' article.versions[0].revert() print(article.name) # 'Some article' Resources Documentation Issue Tracker Code More information http://en.wikipedia.org/wiki/Slowly_changing_dimension http://en.wikipedia.org/wiki/Change_data_capture http://en.wikipedia.org/wiki/Anchor_Modeling http://en.wikipedia.org/wiki/Shadow_table https://wiki.postgresql.org/wiki/Audit_trigger https://wiki.postgresql.org/wiki/Audit_trigger_91plus http://kosalads.blogspot.fi/2014/06/implement-audit-functionality-in.html https://github.com/2ndQuadrant/pgaudit Comparison Primary reasons to create another library: Be future looking and support sqlalchemy 1.4 and 2.x Support multiple databases (sqlite, mysql, postgres, mssql, oracle) Focus on the history tracking and be as efficient as possible when doing it We found multiple libraries which has an implementation of history tracking: sqlalchemy-continuum Does not support oracle, mssql Feature filled making it difficult to maintain all plugins/extensions flask-continuum Thin wrapper on sqlalchemy-continuum specifically for flask postgresql-audit Supports only postgres versionalchemy Not updated in a while No reverting capability, Relationship queries on history not available django-simple-history Uses django ORM, does not support sqlalchemy sqlalchemy example versioning-objects Simple example to demonstrate implementation - but very minimal","title":"Home"},{"location":"#sqlalchemy-history","text":"SQLAlchemy-history is a fork of sqlalchemy-continuum. An auditing extension for sqlalchemy which keeps a track of the history of your sqlalchemy models","title":"SQLAlchemy-History"},{"location":"#features","text":"Supports sqlalchemy 1.4+ and python 3.7+ Tracks history for inserts, deletes, and updates Does not store updates which don't change anything Supports alembic migrations Can revert objects data as well as all object relations at given transaction even if the object was deleted Transactions can be queried afterwards using SQLAlchemy query syntax Query for changed records at given transaction Temporal relationship reflection. Get the relationships of an object in that point in time.","title":"Features"},{"location":"#quickstart","text":"pip install sqlalchemy-history In order to make your models versioned you need two things: Call make_versioned() before your models are defined. Add __versioned__ to all models you wish to add versioning to >>> from sqlalchemy_history import make_versioned >>> make_versioned(user_cls=None) >>> class Article(Base): ... __versioned__ = {} ... __tablename__ = 'article' ... id = sa.Column(sa.Integer, primary_key=True, autoincrement=True) ... name = sa.Column(sa.Unicode(255)) ... content = sa.Column(sa.UnicodeText) >>> article = Article(name='Some article', content='Some content') >>> session.add(article) >>> session.commit() 'article has now one version stored in database' >>> article.versions[0].name 'Some article' >>> article.name = 'Updated name' >>> session.commit() >>> article.versions[1].name 'Updated name' >>> article.versions[0].revert() 'lets revert back to first version' >>> article.name 'Some article' For completeness, below is a working example. from sqlalchemy_history import make_versioned from sqlalchemy import Column, Integer, Unicode, UnicodeText, create_engine try: from sqlalchemy.ext.declarative import declarative_base except ImportError: # sqla > 2.x from sqlalchemy.orm import declarative_base from sqlalchemy.orm import create_session, configure_mappers make_versioned(user_cls=None) Base = declarative_base() class Article(Base): __versioned__ = {} __tablename__ = 'article' id = Column(Integer, primary_key=True, autoincrement=True) name = Column(Unicode(255)) content = Column(UnicodeText) configure_mappers() engine = create_engine('sqlite://') Base.metadata.create_all(engine) session = create_session(bind=engine, autocommit=False) article = Article(name='Some article', content='Some content') session.add(article) session.commit() print(article.versions[0].name) # 'Some article' article.name = 'Updated name' session.commit() print(article.versions[1].name) # 'Updated name' article.versions[0].revert() print(article.name) # 'Some article'","title":"QuickStart"},{"location":"#resources","text":"Documentation Issue Tracker Code","title":"Resources"},{"location":"#more-information","text":"http://en.wikipedia.org/wiki/Slowly_changing_dimension http://en.wikipedia.org/wiki/Change_data_capture http://en.wikipedia.org/wiki/Anchor_Modeling http://en.wikipedia.org/wiki/Shadow_table https://wiki.postgresql.org/wiki/Audit_trigger https://wiki.postgresql.org/wiki/Audit_trigger_91plus http://kosalads.blogspot.fi/2014/06/implement-audit-functionality-in.html https://github.com/2ndQuadrant/pgaudit","title":"More information"},{"location":"#comparison","text":"Primary reasons to create another library: Be future looking and support sqlalchemy 1.4 and 2.x Support multiple databases (sqlite, mysql, postgres, mssql, oracle) Focus on the history tracking and be as efficient as possible when doing it We found multiple libraries which has an implementation of history tracking: sqlalchemy-continuum Does not support oracle, mssql Feature filled making it difficult to maintain all plugins/extensions flask-continuum Thin wrapper on sqlalchemy-continuum specifically for flask postgresql-audit Supports only postgres versionalchemy Not updated in a while No reverting capability, Relationship queries on history not available django-simple-history Uses django ORM, does not support sqlalchemy sqlalchemy example versioning-objects Simple example to demonstrate implementation - but very minimal","title":"Comparison"},{"location":"alembic/","text":"Alembic migrations Each time you make changes to database structure you should also change the associated history tables. When you make changes to your models SQLAlchemy-History automatically alters the history model definitions, hence you can use alembic revision --autogenerate just like before. You just need to make sure make_versioned function gets called before alembic gathers all your models and configure_mappers is called afterwards. Pay close attention when dropping or moving data from parent tables and reflecting these changes to history tables. Troubleshooting If alembic didn't detect any changes or generates reversed migration (tries to remove *_version tables from database instead of creating), make sure that configure_mappers was called by alembic command.","title":"Alembic migrations"},{"location":"alembic/#alembic-migrations","text":"Each time you make changes to database structure you should also change the associated history tables. When you make changes to your models SQLAlchemy-History automatically alters the history model definitions, hence you can use alembic revision --autogenerate just like before. You just need to make sure make_versioned function gets called before alembic gathers all your models and configure_mappers is called afterwards. Pay close attention when dropping or moving data from parent tables and reflecting these changes to history tables.","title":"Alembic migrations"},{"location":"alembic/#troubleshooting","text":"If alembic didn't detect any changes or generates reversed migration (tries to remove *_version tables from database instead of creating), make sure that configure_mappers was called by alembic command.","title":"Troubleshooting"},{"location":"api/","text":"API Documentation Modules exported by this package: make_versioned : This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. remove_versioning : Remove the versioning from given mapper / session and manager. make_versioned(mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager, plugins=None, options=None, user_cls='User') This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. By default this applies to all mappers and all sessions. Examples >>> make_versioned(user_cls=None, options={'table_name': '%_tracker'}) None Parameters: mapper ( sa.orm.Mapper , default: sa . orm . Mapper ) \u2013 SQLAlchemy mapper to apply the versioning to. (Default value = sa.orm.Mapper) session \u2013 SQLAlchemy session to apply the versioning to. By default this is sa.orm.session.Session meaning it applies to all Session subclasses. manager ( VersioningManager , default: versioning_manager ) \u2013 SQLAlchemy-History versioning manager. (Default value = versioning_manager) plugins \u2013 Plugins to pass for versioning manager. (Default value = None) options ( dict , default: None ) \u2013 A dictionary of VersioningManager options. (Default value = None) user_cls \u2013 User class which the Transaction class should have relationship to. This can either be a class or string name of a class for lazy evaluation. (Default value = \"User\") Returns: NoneType \u2013 None sqlalchemy_history/__init__.py def make_versioned( mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager, plugins=None, options=None, user_cls=\"User\", ): \"\"\"This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. By default this applies to all mappers and all sessions. **Examples** >>> make_versioned(user_cls=None, options={'table_name': '%_tracker'}) None :param mapper: SQLAlchemy mapper to apply the versioning to. (Default value = sa.orm.Mapper) :type mapper: sa.orm.Mapper :param session: SQLAlchemy session to apply the versioning to. By default this is sa.orm.session.Session meaning it applies to all Session subclasses. :param manager: SQLAlchemy-History versioning manager. (Default value = versioning_manager) :type manager: VersioningManager :param plugins: Plugins to pass for versioning manager. (Default value = None) :param options: A dictionary of VersioningManager options. (Default value = None) :type options: dict :param user_cls: User class which the Transaction class should have relationship to. This can either be a class or string name of a class for lazy evaluation. (Default value = \"User\") :returns: None :rtype: NoneType \"\"\" if plugins is not None: manager.plugins = plugins if options is not None: manager.options.update(options) manager.user_cls = user_cls manager.apply_class_configuration_listeners(mapper) manager.track_operations(mapper) manager.track_session(session) sa.event.listen(sa.engine.Engine, \"before_cursor_execute\", manager.track_sql_operations) sa.event.listen(sa.engine.Engine, \"rollback\", manager.clear_connection) sa.event.listen( sa.engine.Engine, \"set_connection_execution_options\", manager.track_cloned_connections, ) remove_versioning(mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager) Remove the versioning from given mapper / session and manager. Examples >>> remove_versioning() None Parameters: mapper ( sa.orm.Mapper , default: sa . orm . Mapper ) \u2013 SQLAlchemy mapper to remove the versioning from. (Default value = sa.orm.Mapper) session \u2013 SQLAlchemy session to remove the versioning from. By default this is sa.orm.session.Session meaning it applies to all sessions. (Default value = sa.orm.session.Session) manager ( VersioningManager , default: versioning_manager ) \u2013 SQLAlchemy-History versioning manager. (Default value = versioning_manager) Returns: NoneType \u2013 None sqlalchemy_history/__init__.py def remove_versioning(mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager): \"\"\"Remove the versioning from given mapper / session and manager. **Examples** >>> remove_versioning() None :param mapper: SQLAlchemy mapper to remove the versioning from. (Default value = sa.orm.Mapper) :type mapper: sa.orm.Mapper :param session: SQLAlchemy session to remove the versioning from. By default this is sa.orm.session.Session meaning it applies to all sessions. (Default value = sa.orm.session.Session) :param manager: SQLAlchemy-History versioning manager. (Default value = versioning_manager) :type manager: VersioningManager :returns: None :rtype: NoneType \"\"\" manager.reset() manager.remove_class_configuration_listeners(mapper) manager.remove_operations_tracking(mapper) manager.remove_session_tracking(session) sa.event.remove(sa.engine.Engine, \"before_cursor_execute\", manager.track_sql_operations) sa.event.remove(sa.engine.Engine, \"rollback\", manager.clear_connection) sa.event.remove( sa.engine.Engine, \"set_connection_execution_options\", manager.track_cloned_connections, )","title":"API Documentation"},{"location":"api/#api-documentation","text":"Modules exported by this package: make_versioned : This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. remove_versioning : Remove the versioning from given mapper / session and manager.","title":"API Documentation"},{"location":"api/#sqlalchemy_history.make_versioned","text":"This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. By default this applies to all mappers and all sessions. Examples >>> make_versioned(user_cls=None, options={'table_name': '%_tracker'}) None Parameters: mapper ( sa.orm.Mapper , default: sa . orm . Mapper ) \u2013 SQLAlchemy mapper to apply the versioning to. (Default value = sa.orm.Mapper) session \u2013 SQLAlchemy session to apply the versioning to. By default this is sa.orm.session.Session meaning it applies to all Session subclasses. manager ( VersioningManager , default: versioning_manager ) \u2013 SQLAlchemy-History versioning manager. (Default value = versioning_manager) plugins \u2013 Plugins to pass for versioning manager. (Default value = None) options ( dict , default: None ) \u2013 A dictionary of VersioningManager options. (Default value = None) user_cls \u2013 User class which the Transaction class should have relationship to. This can either be a class or string name of a class for lazy evaluation. (Default value = \"User\") Returns: NoneType \u2013 None sqlalchemy_history/__init__.py def make_versioned( mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager, plugins=None, options=None, user_cls=\"User\", ): \"\"\"This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. By default this applies to all mappers and all sessions. **Examples** >>> make_versioned(user_cls=None, options={'table_name': '%_tracker'}) None :param mapper: SQLAlchemy mapper to apply the versioning to. (Default value = sa.orm.Mapper) :type mapper: sa.orm.Mapper :param session: SQLAlchemy session to apply the versioning to. By default this is sa.orm.session.Session meaning it applies to all Session subclasses. :param manager: SQLAlchemy-History versioning manager. (Default value = versioning_manager) :type manager: VersioningManager :param plugins: Plugins to pass for versioning manager. (Default value = None) :param options: A dictionary of VersioningManager options. (Default value = None) :type options: dict :param user_cls: User class which the Transaction class should have relationship to. This can either be a class or string name of a class for lazy evaluation. (Default value = \"User\") :returns: None :rtype: NoneType \"\"\" if plugins is not None: manager.plugins = plugins if options is not None: manager.options.update(options) manager.user_cls = user_cls manager.apply_class_configuration_listeners(mapper) manager.track_operations(mapper) manager.track_session(session) sa.event.listen(sa.engine.Engine, \"before_cursor_execute\", manager.track_sql_operations) sa.event.listen(sa.engine.Engine, \"rollback\", manager.clear_connection) sa.event.listen( sa.engine.Engine, \"set_connection_execution_options\", manager.track_cloned_connections, )","title":"make_versioned()"},{"location":"api/#sqlalchemy_history.remove_versioning","text":"Remove the versioning from given mapper / session and manager. Examples >>> remove_versioning() None Parameters: mapper ( sa.orm.Mapper , default: sa . orm . Mapper ) \u2013 SQLAlchemy mapper to remove the versioning from. (Default value = sa.orm.Mapper) session \u2013 SQLAlchemy session to remove the versioning from. By default this is sa.orm.session.Session meaning it applies to all sessions. (Default value = sa.orm.session.Session) manager ( VersioningManager , default: versioning_manager ) \u2013 SQLAlchemy-History versioning manager. (Default value = versioning_manager) Returns: NoneType \u2013 None sqlalchemy_history/__init__.py def remove_versioning(mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager): \"\"\"Remove the versioning from given mapper / session and manager. **Examples** >>> remove_versioning() None :param mapper: SQLAlchemy mapper to remove the versioning from. (Default value = sa.orm.Mapper) :type mapper: sa.orm.Mapper :param session: SQLAlchemy session to remove the versioning from. By default this is sa.orm.session.Session meaning it applies to all sessions. (Default value = sa.orm.session.Session) :param manager: SQLAlchemy-History versioning manager. (Default value = versioning_manager) :type manager: VersioningManager :returns: None :rtype: NoneType \"\"\" manager.reset() manager.remove_class_configuration_listeners(mapper) manager.remove_operations_tracking(mapper) manager.remove_session_tracking(session) sa.event.remove(sa.engine.Engine, \"before_cursor_execute\", manager.track_sql_operations) sa.event.remove(sa.engine.Engine, \"rollback\", manager.clear_connection) sa.event.remove( sa.engine.Engine, \"set_connection_execution_options\", manager.track_cloned_connections, )","title":"remove_versioning()"},{"location":"configuration/","text":"Configuration Global and class level configuration All configuration parameters can be set on global level (manager level) and on class level. Setting an option at manager level affects all classes within the scope of the manager's class instrumentation listener (by default all SQLAlchemy declarative models). In the following example we set 'transaction_column_name' configuration option to my_tx_id at the manager level. >>> make_versioned(options={'transaction_column_name': 'my_tx_id'}) As the name suggests class level configuration only applies to given class. Class level configuration can be passed to versioned class attribute. >>> class User(Base): ... __versioned__ = { ... 'transaction_column_name': 'tx_id' ... } Versioning strategies Similar to Hibernate Envers SQLAlchemy-History offers two distinct versioning strategies 'validity' and 'subquery'. The default strategy is 'validity'. Validity The 'validity' strategy saves two columns in each history table, namely 'transaction_id' and 'end_transaction_id'. The names of these columns can be configured with configuration options transaction_column_name and end_transaction_column_name . As with 'subquery' strategy for each inserted, updated and deleted entity SQLA-History creates new version in the history table. However it also updates the end_transaction_id of the previous version to point at the current version. This creates a little bit of overhead during data manipulation. With 'validity' strategy version traversal is very fast. When accessing previous version SQLA-History tries to find the version record where the primary keys match and end_transaction_id is the same as the transaction_id of the given version record. When accessing the next version SQLA-History tries to find the version record where the primary keys match and transaction_id is the same as the end_transaction_id of the given version record. Pros: - Version traversal is much faster since no correlated subqueries are needed Cons: - Updates, inserts and deletes are little bit slower Subquery The 'subquery' strategy uses one column in each history table, namely 'transaction_id'. The name of this column can be configured with configuration option transaction_column_name . After each inserted, updated and deleted entity SQLA-History creates new version in the history table and sets the 'transaction_id' column to point at the current transaction. With 'subquery' strategy the version traversal is slow. When accessing previous and next versions of given version object needs correlated subqueries. Pros: - Updates, inserts and deletes little bit faster than in 'validity' strategy Cons: - Version traversel much slower Column exclusion and inclusion With exclude configuration option you can define which entity attributes you want to get versioned. By default SQLA-History versions all entity attributes. >>> class User(Base): ... __versioned__ = { ... 'exclude': ['picture'] ... } ... id = sa.Column(sa.Integer, primary_key=True) ... name = sa.Column(sa.Unicode(255)) ... picture = sa.Column(sa.LargeBinary) Basic configuration options Here is a full list of configuration options: base_classes (default: None) A tuple defining history class base classes. table_name (default: '%s_version') The name of the history table. transaction_column_name (default: 'transaction_id') The name of the transaction column (used by history tables). end_transaction_column_name (default: 'end_transaction_id') The name of the end transaction column in history table when using the validity versioning strategy. operation_type_column_name (default: 'operation_type') The name of the operation type column (used by history tables). strategy (default: 'validity') The versioning strategy to use. Either 'validity' or 'subquery' Example >>> class Article(Base): ... __versioned__ = { ... 'transaction_column_name': 'tx_id' ... } ... __tablename__ = 'user' ... id = sa.Column(sa.Integer, primary_key=True, autoincrement=True) ... name = sa.Column(sa.Unicode(255)) ... content = sa.Column(sa.UnicodeText) Customizing transaction user class By default SQLA-History tries to build a relationship between 'User' class and Transaction class. If you have differently named user class you can simply pass its name to make_versioned: >>> make_versioned(user_cls='MyUserClass') If you don't want transactions to contain any user references you can also disable this feature. >>> make_versioned(user_cls=None) Customizing versioned mappers By default SQLAlchemy-History versions all mappers. You can override this behaviour by passing the desired mapper class/object to make_versioned function. >>> make_versioned(mapper=my_mapper) Customizing versioned sessions By default SQLAlchemy-History versions all sessions. You can override this behaviour by passing the desired session class/object to make_versioned function. >>> make_versioned(session=my_session)","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#global-and-class-level-configuration","text":"All configuration parameters can be set on global level (manager level) and on class level. Setting an option at manager level affects all classes within the scope of the manager's class instrumentation listener (by default all SQLAlchemy declarative models). In the following example we set 'transaction_column_name' configuration option to my_tx_id at the manager level. >>> make_versioned(options={'transaction_column_name': 'my_tx_id'}) As the name suggests class level configuration only applies to given class. Class level configuration can be passed to versioned class attribute. >>> class User(Base): ... __versioned__ = { ... 'transaction_column_name': 'tx_id' ... }","title":"Global and class level configuration"},{"location":"configuration/#versioning-strategies","text":"Similar to Hibernate Envers SQLAlchemy-History offers two distinct versioning strategies 'validity' and 'subquery'. The default strategy is 'validity'.","title":"Versioning strategies"},{"location":"configuration/#validity","text":"The 'validity' strategy saves two columns in each history table, namely 'transaction_id' and 'end_transaction_id'. The names of these columns can be configured with configuration options transaction_column_name and end_transaction_column_name . As with 'subquery' strategy for each inserted, updated and deleted entity SQLA-History creates new version in the history table. However it also updates the end_transaction_id of the previous version to point at the current version. This creates a little bit of overhead during data manipulation. With 'validity' strategy version traversal is very fast. When accessing previous version SQLA-History tries to find the version record where the primary keys match and end_transaction_id is the same as the transaction_id of the given version record. When accessing the next version SQLA-History tries to find the version record where the primary keys match and transaction_id is the same as the end_transaction_id of the given version record. Pros: - Version traversal is much faster since no correlated subqueries are needed Cons: - Updates, inserts and deletes are little bit slower","title":"Validity"},{"location":"configuration/#subquery","text":"The 'subquery' strategy uses one column in each history table, namely 'transaction_id'. The name of this column can be configured with configuration option transaction_column_name . After each inserted, updated and deleted entity SQLA-History creates new version in the history table and sets the 'transaction_id' column to point at the current transaction. With 'subquery' strategy the version traversal is slow. When accessing previous and next versions of given version object needs correlated subqueries. Pros: - Updates, inserts and deletes little bit faster than in 'validity' strategy Cons: - Version traversel much slower","title":"Subquery"},{"location":"configuration/#column-exclusion-and-inclusion","text":"With exclude configuration option you can define which entity attributes you want to get versioned. By default SQLA-History versions all entity attributes. >>> class User(Base): ... __versioned__ = { ... 'exclude': ['picture'] ... } ... id = sa.Column(sa.Integer, primary_key=True) ... name = sa.Column(sa.Unicode(255)) ... picture = sa.Column(sa.LargeBinary)","title":"Column exclusion and inclusion"},{"location":"configuration/#basic-configuration-options","text":"Here is a full list of configuration options: base_classes (default: None) A tuple defining history class base classes. table_name (default: '%s_version') The name of the history table. transaction_column_name (default: 'transaction_id') The name of the transaction column (used by history tables). end_transaction_column_name (default: 'end_transaction_id') The name of the end transaction column in history table when using the validity versioning strategy. operation_type_column_name (default: 'operation_type') The name of the operation type column (used by history tables). strategy (default: 'validity') The versioning strategy to use. Either 'validity' or 'subquery' Example >>> class Article(Base): ... __versioned__ = { ... 'transaction_column_name': 'tx_id' ... } ... __tablename__ = 'user' ... id = sa.Column(sa.Integer, primary_key=True, autoincrement=True) ... name = sa.Column(sa.Unicode(255)) ... content = sa.Column(sa.UnicodeText)","title":"Basic configuration options"},{"location":"configuration/#customizing-transaction-user-class","text":"By default SQLA-History tries to build a relationship between 'User' class and Transaction class. If you have differently named user class you can simply pass its name to make_versioned: >>> make_versioned(user_cls='MyUserClass') If you don't want transactions to contain any user references you can also disable this feature. >>> make_versioned(user_cls=None)","title":"Customizing transaction user class"},{"location":"configuration/#customizing-versioned-mappers","text":"By default SQLAlchemy-History versions all mappers. You can override this behaviour by passing the desired mapper class/object to make_versioned function. >>> make_versioned(mapper=my_mapper)","title":"Customizing versioned mappers"},{"location":"configuration/#customizing-versioned-sessions","text":"By default SQLAlchemy-History versions all sessions. You can override this behaviour by passing the desired session class/object to make_versioned function. >>> make_versioned(session=my_session)","title":"Customizing versioned sessions"},{"location":"plugins/","text":"Plugins >>> from sqlalchemy_history.plugins import PropertyModTrackerPlugin >>> versioning_manager.plugins.append(PropertyModTrackerPlugin()) >>> versioning_manager.plugins <PluginCollection [...]> >>> del versioning_manager.plugins[0] # You can also remove plugin Activity The ActivityPlugin is the most powerful plugin for tracking changes of individual entities. If you use ActivityPlugin you probably don't need to use TransactionChanges nor TransactionMeta plugins. You can initalize the ActivityPlugin by adding it to versioning manager. >>> activity_plugin = ActivityPlugin() >>> make_versioned(plugins=[activity_plugin]) ActivityPlugin uses single database table for tracking activities. This table follows the data structure in activity stream specification _, but it comes with a nice twist: |Column |Type |Description |:-------------: |:---------: |:------------: |id |BigInteger |The primary key of the activity |verb |Unicode |Verb defines the action of the activity |data |JSON |Additional data for the activity in JSON format |transaction_id |BigInteger |The transaction this activity was associated with |object_id |BigInteger |The primary key of the object. Object can be any entity which has an integer as primary key. |object_type |Unicode |The type of the object (class name as string) |object_tx_id |BigInteger |The last transaction_id associated with the object. This is used for efficiently fetching the object version associated with this activity. |target_id |BigInteger |The primary key of the target. Target can be any entity which has an integer as primary key. |target_type |Unicode |The of the target (class name as string) |target_tx_id |BigInteger |The last transaction_id associated with the target. Each Activity has relationships to actor, object and target but it also holds information about the associated transaction and about the last associated transactions with the target and object. This allows each activity to also have object_version and target_version relationships for introspecting what those objects and targets were in given point in time. All these relationship properties use generic relationships _ of the SQLAlchemy-Utils package. Limitations Currently all changes to parent models must be flushed or committed before creating activities. This is due to a fact that there is still no dependency processors for generic relationships. So when you create activities and assign objects / targets for those please remember to flush the session before creating an activity:: >>> article = Article(name=u'Some article') >>> session.add(article) >>> session.flush() # <- IMPORTANT! >>> first_activity = Activity(verb=u'create', object=article) >>> session.add(first_activity) >>> session.commit() Targets and objects of given activity must have an integer primary key column id. Create activities Once your models have been configured you can get the Activity model from the ActivityPlugin class with activity_cls property:: Activity = activity_plugin.activity_cls Now let's say we have model called Article and Category. Each Article has one Category. Activities should be created along with the changes you make on these models. >>> article = Article(name=u'Some article') >>> session.add(article) >>> session.flush() >>> first_activity = Activity(verb=u'create', object=article) >>> session.add(first_activity) >>> session.commit() Current transaction gets automatically assigned to activity object:: >>> first_activity.transaction # Transaction object Update activities The object property of the Activity object holds the current object and the object_version holds the object version at the time when the activity was created. >>> article.name = u'Some article updated!' >>> session.flush() >>> second_activity = Activity(verb=u'update', object=article) >>> session.add(second_activity) >>> session.commit() >>> second_activity.object.name # u'Some article updated!' >>> first_activity.object.name # u'Some article updated!' >>> first_activity.object_version.name # u'Some article' Delete activities The version properties are especially useful for delete activities. Once the activity is fetched from the database the object is no longer available ( since its deleted), hence the only way we could show some information about the object the user deleted is by accessing the object_version property. >>> session.delete(article) >>> session.flush() >>> third_activity = Activity(verb=u'delete', object=article) >>> session.add(third_activity) >>> session.commit() >>> third_activity.object_version.name # u'Some article updated!' Local version histories using targets The target property of the Activity model offers a way of tracking changes of given related object. In the example below we create a new activity when adding a category for article and then mark the article as the target of this activity. >>> session.add(Category(name=u'Fist category', article=article)) >>> session.flush() >>> activity = Activity( ... verb=u'create', ... object=category, ... target=article ... ) >>> session.add(activity) >>> session.commit() Now if we wanted to find all the changes that affected given article we could do so by searching through all the activities where either the object or target is the given article. >>> import sqlalchemy as sa >>> activities = session.query(Activity).filter( ... sa.or_( ... Activity.object == article, ... Activity.target == article ... ) ... ) Also Read _activity stream specification _generic relationships ActivityFactory Bases: ModelFactory Source code in sqlalchemy_history/plugins/activity.py class ActivityFactory(ModelFactory): model_name = \"Activity\" def create_class(self, manager): \"\"\"Create Activity class. :param manager: \"\"\" class Activity(manager.declarative_base, ActivityBase): __tablename__ = \"activity\" manager = self transaction_id = sa.Column(sa.BigInteger, index=True, nullable=False) data = sa.Column(JSONType) object_type = sa.Column(sa.String(255)) object_id = sa.Column(sa.BigInteger) object_tx_id = sa.Column(sa.BigInteger) target_type = sa.Column(sa.String(255)) target_id = sa.Column(sa.BigInteger) target_tx_id = sa.Column(sa.BigInteger) def _calculate_tx_id(self, obj): session = sa.orm.object_session(self) if obj: object_version = version_obj(session, obj) if object_version: return object_version.transaction_id model = obj.__class__ version_cls = version_class(model) primary_key = inspect(model).primary_key[0].name return ( session.query(sa.func.max(version_cls.transaction_id)) .filter(getattr(version_cls, primary_key) == getattr(obj, primary_key)) .scalar() ) def calculate_object_tx_id(self): self.object_tx_id = self._calculate_tx_id(self.object) def calculate_target_tx_id(self): self.target_tx_id = self._calculate_tx_id(self.target) object = generic_relationship(object_type, object_id) @hybrid_property def object_version_type(self): return self.object_type + \"Version\" @object_version_type.expression def object_version_type(cls): return sa.func.concat(cls.object_type, \"Version\") object_version = generic_relationship(object_version_type, (object_id, object_tx_id)) target = generic_relationship(target_type, target_id) @hybrid_property def target_version_type(self): return self.target_type + \"Version\" @target_version_type.expression def target_version_type(cls): return sa.func.concat(cls.target_type, \"Version\") target_version = generic_relationship(target_version_type, (target_id, target_tx_id)) Activity.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref( \"activities\", ), primaryjoin=(\"%s.id == Activity.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[Activity.transaction_id], ) return Activity create_class(manager) Create Activity class. Parameters: manager \u2013 sqlalchemy_history/plugins/activity.py def create_class(self, manager): \"\"\"Create Activity class. :param manager: \"\"\" class Activity(manager.declarative_base, ActivityBase): __tablename__ = \"activity\" manager = self transaction_id = sa.Column(sa.BigInteger, index=True, nullable=False) data = sa.Column(JSONType) object_type = sa.Column(sa.String(255)) object_id = sa.Column(sa.BigInteger) object_tx_id = sa.Column(sa.BigInteger) target_type = sa.Column(sa.String(255)) target_id = sa.Column(sa.BigInteger) target_tx_id = sa.Column(sa.BigInteger) def _calculate_tx_id(self, obj): session = sa.orm.object_session(self) if obj: object_version = version_obj(session, obj) if object_version: return object_version.transaction_id model = obj.__class__ version_cls = version_class(model) primary_key = inspect(model).primary_key[0].name return ( session.query(sa.func.max(version_cls.transaction_id)) .filter(getattr(version_cls, primary_key) == getattr(obj, primary_key)) .scalar() ) def calculate_object_tx_id(self): self.object_tx_id = self._calculate_tx_id(self.object) def calculate_target_tx_id(self): self.target_tx_id = self._calculate_tx_id(self.target) object = generic_relationship(object_type, object_id) @hybrid_property def object_version_type(self): return self.object_type + \"Version\" @object_version_type.expression def object_version_type(cls): return sa.func.concat(cls.object_type, \"Version\") object_version = generic_relationship(object_version_type, (object_id, object_tx_id)) target = generic_relationship(target_type, target_id) @hybrid_property def target_version_type(self): return self.target_type + \"Version\" @target_version_type.expression def target_version_type(cls): return sa.func.concat(cls.target_type, \"Version\") target_version = generic_relationship(target_version_type, (target_id, target_tx_id)) Activity.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref( \"activities\", ), primaryjoin=(\"%s.id == Activity.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[Activity.transaction_id], ) return Activity ActivityPlugin Bases: Plugin Source code in sqlalchemy_history/plugins/activity.py class ActivityPlugin(Plugin): activity_cls = None def after_build_models(self, manager): self.activity_cls = ActivityFactory()(manager) manager.activity_cls = self.activity_cls def is_session_modified(self, session): \"\"\"Return that the session has been modified if the session contains an activity class. :param session: SQLAlchemy session object \"\"\" return any(isinstance(obj, self.activity_cls) for obj in session) def before_flush(self, uow, session): for obj in session: if isinstance(obj, self.activity_cls): obj.transaction = uow.current_transaction obj.calculate_target_tx_id() obj.calculate_object_tx_id() def after_version_class_built(self, parent_cls, version_cls): pass is_session_modified(session) Return that the session has been modified if the session contains an activity class. Parameters: session \u2013 SQLAlchemy session object sqlalchemy_history/plugins/activity.py def is_session_modified(self, session): \"\"\"Return that the session has been modified if the session contains an activity class. :param session: SQLAlchemy session object \"\"\" return any(isinstance(obj, self.activity_cls) for obj in session) PropertyModTracker The PropertyModTrackerPlugin offers a way of efficiently tracking individual property modifications. With PropertyModTrackerPlugin you can make efficient queries such as: Find all versions of model X where user updated the property A or property B. Find all versions of model X where user didn't update property A. PropertyModTrackerPlugin adds separate modified tracking column for each versioned column. So for example if you have versioned model called Article with columns name and content , this plugin would add two additional boolean columns name_mod and content_mod for the version model. When user commits transactions the plugin automatically updates these boolean columns. TransactionChanges TransactionChanges provides way of keeping track efficiently which declarative models were changed in given transaction. This can be useful when transactions need to be queried afterwards for problems such as: Find all transactions which affected User model. Find all transactions which didn't affect models Entity and Event . The plugin works in two ways. On class instrumentation phase this plugin creates a special transaction model called TransactionChanges . This model is associated with table called transaction_changes , which has only only two fields: transaction_id and entity_name. If for example transaction consisted of saving 5 new User entities and 1 Article entity, two new rows would be inserted into transaction_changes table. ================ ================= transaction_id entity_name ---------------- ----------------- 233678 User 233678 Article ================ ================= TransactionChangesFactory Bases: ModelFactory Source code in sqlalchemy_history/plugins/transaction_changes.py class TransactionChangesFactory(ModelFactory): model_name = \"TransactionChanges\" def create_class(self, manager): \"\"\"Create TransactionChanges class. :param manager: \"\"\" class TransactionChanges(manager.declarative_base, TransactionChangesBase): __tablename__ = \"transaction_changes\" TransactionChanges.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref( \"changes\", ), primaryjoin=(\"%s.id == TransactionChanges.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[TransactionChanges.transaction_id], ) return TransactionChanges create_class(manager) Create TransactionChanges class. Parameters: manager \u2013 sqlalchemy_history/plugins/transaction_changes.py def create_class(self, manager): \"\"\"Create TransactionChanges class. :param manager: \"\"\" class TransactionChanges(manager.declarative_base, TransactionChangesBase): __tablename__ = \"transaction_changes\" TransactionChanges.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref( \"changes\", ), primaryjoin=(\"%s.id == TransactionChanges.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[TransactionChanges.transaction_id], ) return TransactionChanges TransactionMeta TransactionMetaPlugin offers a way of saving key-value data for transations. You can use the plugin in same way as other plugins:: meta_plugin = TransactionMetaPlugin() versioning_manager.plugins.add(meta_plugin) TransactionMetaPlugin creates a simple model called TransactionMeta. This class has three columns: transaction_id, key and value. TransactionMeta plugin also creates an association proxy between TransactionMeta and Transaction classes for easy dictionary based access of key-value pairs. You can easily 'tag' transactions with certain key value pairs by giving these keys and values to the meta property of Transaction class. :: from sqlalchemy_history import versioning_manager article = Article() session.add(article) uow = versioning_manager.unit_of_work(session) tx = uow.create_transaction(session) tx.meta = {u'some_key': u'some value'} session.commit() TransactionMeta = meta_plugin.model_class Transaction = versioning_manager.transaction_cls # find all transactions with 'article' tags query = ( session.query(Transaction) .join(Transaction.meta_relation) .filter( db.and_( TransactionMeta.key == 'some_key', TransactionMeta.value == 'some value' ) ) ) TransactionMetaFactory Bases: ModelFactory Source code in sqlalchemy_history/plugins/transaction_meta.py class TransactionMetaFactory(ModelFactory): model_name = \"TransactionMeta\" def create_class(self, manager): \"\"\"Create TransactionMeta class. :param manager: \"\"\" class TransactionMeta(manager.declarative_base, TransactionMetaBase): __tablename__ = \"transaction_meta\" TransactionMeta.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref(\"meta_relation\", collection_class=attribute_mapped_collection(\"key\")), primaryjoin=(\"%s.id == TransactionMeta.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[TransactionMeta.transaction_id], ) manager.transaction_cls.meta = association_proxy( \"meta_relation\", \"value\", creator=lambda key, value: TransactionMeta(key=key, value=value), ) return TransactionMeta create_class(manager) Create TransactionMeta class. Parameters: manager \u2013 sqlalchemy_history/plugins/transaction_meta.py def create_class(self, manager): \"\"\"Create TransactionMeta class. :param manager: \"\"\" class TransactionMeta(manager.declarative_base, TransactionMetaBase): __tablename__ = \"transaction_meta\" TransactionMeta.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref(\"meta_relation\", collection_class=attribute_mapped_collection(\"key\")), primaryjoin=(\"%s.id == TransactionMeta.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[TransactionMeta.transaction_id], ) manager.transaction_cls.meta = association_proxy( \"meta_relation\", \"value\", creator=lambda key, value: TransactionMeta(key=key, value=value), ) return TransactionMeta","title":"Plugins"},{"location":"plugins/#plugins","text":">>> from sqlalchemy_history.plugins import PropertyModTrackerPlugin >>> versioning_manager.plugins.append(PropertyModTrackerPlugin()) >>> versioning_manager.plugins <PluginCollection [...]> >>> del versioning_manager.plugins[0] # You can also remove plugin","title":"Plugins"},{"location":"plugins/#activity","text":"The ActivityPlugin is the most powerful plugin for tracking changes of individual entities. If you use ActivityPlugin you probably don't need to use TransactionChanges nor TransactionMeta plugins. You can initalize the ActivityPlugin by adding it to versioning manager. >>> activity_plugin = ActivityPlugin() >>> make_versioned(plugins=[activity_plugin]) ActivityPlugin uses single database table for tracking activities. This table follows the data structure in activity stream specification _, but it comes with a nice twist: |Column |Type |Description |:-------------: |:---------: |:------------: |id |BigInteger |The primary key of the activity |verb |Unicode |Verb defines the action of the activity |data |JSON |Additional data for the activity in JSON format |transaction_id |BigInteger |The transaction this activity was associated with |object_id |BigInteger |The primary key of the object. Object can be any entity which has an integer as primary key. |object_type |Unicode |The type of the object (class name as string) |object_tx_id |BigInteger |The last transaction_id associated with the object. This is used for efficiently fetching the object version associated with this activity. |target_id |BigInteger |The primary key of the target. Target can be any entity which has an integer as primary key. |target_type |Unicode |The of the target (class name as string) |target_tx_id |BigInteger |The last transaction_id associated with the target. Each Activity has relationships to actor, object and target but it also holds information about the associated transaction and about the last associated transactions with the target and object. This allows each activity to also have object_version and target_version relationships for introspecting what those objects and targets were in given point in time. All these relationship properties use generic relationships _ of the SQLAlchemy-Utils package.","title":"Activity"},{"location":"plugins/#sqlalchemy_history.plugins.activity--limitations","text":"Currently all changes to parent models must be flushed or committed before creating activities. This is due to a fact that there is still no dependency processors for generic relationships. So when you create activities and assign objects / targets for those please remember to flush the session before creating an activity:: >>> article = Article(name=u'Some article') >>> session.add(article) >>> session.flush() # <- IMPORTANT! >>> first_activity = Activity(verb=u'create', object=article) >>> session.add(first_activity) >>> session.commit() Targets and objects of given activity must have an integer primary key column id.","title":"Limitations"},{"location":"plugins/#sqlalchemy_history.plugins.activity--create-activities","text":"Once your models have been configured you can get the Activity model from the ActivityPlugin class with activity_cls property:: Activity = activity_plugin.activity_cls Now let's say we have model called Article and Category. Each Article has one Category. Activities should be created along with the changes you make on these models. >>> article = Article(name=u'Some article') >>> session.add(article) >>> session.flush() >>> first_activity = Activity(verb=u'create', object=article) >>> session.add(first_activity) >>> session.commit() Current transaction gets automatically assigned to activity object:: >>> first_activity.transaction # Transaction object","title":"Create activities"},{"location":"plugins/#sqlalchemy_history.plugins.activity--update-activities","text":"The object property of the Activity object holds the current object and the object_version holds the object version at the time when the activity was created. >>> article.name = u'Some article updated!' >>> session.flush() >>> second_activity = Activity(verb=u'update', object=article) >>> session.add(second_activity) >>> session.commit() >>> second_activity.object.name # u'Some article updated!' >>> first_activity.object.name # u'Some article updated!' >>> first_activity.object_version.name # u'Some article'","title":"Update activities"},{"location":"plugins/#sqlalchemy_history.plugins.activity--delete-activities","text":"The version properties are especially useful for delete activities. Once the activity is fetched from the database the object is no longer available ( since its deleted), hence the only way we could show some information about the object the user deleted is by accessing the object_version property. >>> session.delete(article) >>> session.flush() >>> third_activity = Activity(verb=u'delete', object=article) >>> session.add(third_activity) >>> session.commit() >>> third_activity.object_version.name # u'Some article updated!'","title":"Delete activities"},{"location":"plugins/#sqlalchemy_history.plugins.activity--local-version-histories-using-targets","text":"The target property of the Activity model offers a way of tracking changes of given related object. In the example below we create a new activity when adding a category for article and then mark the article as the target of this activity. >>> session.add(Category(name=u'Fist category', article=article)) >>> session.flush() >>> activity = Activity( ... verb=u'create', ... object=category, ... target=article ... ) >>> session.add(activity) >>> session.commit() Now if we wanted to find all the changes that affected given article we could do so by searching through all the activities where either the object or target is the given article. >>> import sqlalchemy as sa >>> activities = session.query(Activity).filter( ... sa.or_( ... Activity.object == article, ... Activity.target == article ... ) ... )","title":"Local version histories using targets"},{"location":"plugins/#sqlalchemy_history.plugins.activity--also-read","text":"_activity stream specification _generic relationships","title":"Also Read"},{"location":"plugins/#sqlalchemy_history.plugins.activity.ActivityFactory","text":"Bases: ModelFactory Source code in sqlalchemy_history/plugins/activity.py class ActivityFactory(ModelFactory): model_name = \"Activity\" def create_class(self, manager): \"\"\"Create Activity class. :param manager: \"\"\" class Activity(manager.declarative_base, ActivityBase): __tablename__ = \"activity\" manager = self transaction_id = sa.Column(sa.BigInteger, index=True, nullable=False) data = sa.Column(JSONType) object_type = sa.Column(sa.String(255)) object_id = sa.Column(sa.BigInteger) object_tx_id = sa.Column(sa.BigInteger) target_type = sa.Column(sa.String(255)) target_id = sa.Column(sa.BigInteger) target_tx_id = sa.Column(sa.BigInteger) def _calculate_tx_id(self, obj): session = sa.orm.object_session(self) if obj: object_version = version_obj(session, obj) if object_version: return object_version.transaction_id model = obj.__class__ version_cls = version_class(model) primary_key = inspect(model).primary_key[0].name return ( session.query(sa.func.max(version_cls.transaction_id)) .filter(getattr(version_cls, primary_key) == getattr(obj, primary_key)) .scalar() ) def calculate_object_tx_id(self): self.object_tx_id = self._calculate_tx_id(self.object) def calculate_target_tx_id(self): self.target_tx_id = self._calculate_tx_id(self.target) object = generic_relationship(object_type, object_id) @hybrid_property def object_version_type(self): return self.object_type + \"Version\" @object_version_type.expression def object_version_type(cls): return sa.func.concat(cls.object_type, \"Version\") object_version = generic_relationship(object_version_type, (object_id, object_tx_id)) target = generic_relationship(target_type, target_id) @hybrid_property def target_version_type(self): return self.target_type + \"Version\" @target_version_type.expression def target_version_type(cls): return sa.func.concat(cls.target_type, \"Version\") target_version = generic_relationship(target_version_type, (target_id, target_tx_id)) Activity.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref( \"activities\", ), primaryjoin=(\"%s.id == Activity.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[Activity.transaction_id], ) return Activity","title":"ActivityFactory"},{"location":"plugins/#sqlalchemy_history.plugins.activity.ActivityFactory.create_class","text":"Create Activity class. Parameters: manager \u2013 sqlalchemy_history/plugins/activity.py def create_class(self, manager): \"\"\"Create Activity class. :param manager: \"\"\" class Activity(manager.declarative_base, ActivityBase): __tablename__ = \"activity\" manager = self transaction_id = sa.Column(sa.BigInteger, index=True, nullable=False) data = sa.Column(JSONType) object_type = sa.Column(sa.String(255)) object_id = sa.Column(sa.BigInteger) object_tx_id = sa.Column(sa.BigInteger) target_type = sa.Column(sa.String(255)) target_id = sa.Column(sa.BigInteger) target_tx_id = sa.Column(sa.BigInteger) def _calculate_tx_id(self, obj): session = sa.orm.object_session(self) if obj: object_version = version_obj(session, obj) if object_version: return object_version.transaction_id model = obj.__class__ version_cls = version_class(model) primary_key = inspect(model).primary_key[0].name return ( session.query(sa.func.max(version_cls.transaction_id)) .filter(getattr(version_cls, primary_key) == getattr(obj, primary_key)) .scalar() ) def calculate_object_tx_id(self): self.object_tx_id = self._calculate_tx_id(self.object) def calculate_target_tx_id(self): self.target_tx_id = self._calculate_tx_id(self.target) object = generic_relationship(object_type, object_id) @hybrid_property def object_version_type(self): return self.object_type + \"Version\" @object_version_type.expression def object_version_type(cls): return sa.func.concat(cls.object_type, \"Version\") object_version = generic_relationship(object_version_type, (object_id, object_tx_id)) target = generic_relationship(target_type, target_id) @hybrid_property def target_version_type(self): return self.target_type + \"Version\" @target_version_type.expression def target_version_type(cls): return sa.func.concat(cls.target_type, \"Version\") target_version = generic_relationship(target_version_type, (target_id, target_tx_id)) Activity.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref( \"activities\", ), primaryjoin=(\"%s.id == Activity.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[Activity.transaction_id], ) return Activity","title":"create_class()"},{"location":"plugins/#sqlalchemy_history.plugins.activity.ActivityPlugin","text":"Bases: Plugin Source code in sqlalchemy_history/plugins/activity.py class ActivityPlugin(Plugin): activity_cls = None def after_build_models(self, manager): self.activity_cls = ActivityFactory()(manager) manager.activity_cls = self.activity_cls def is_session_modified(self, session): \"\"\"Return that the session has been modified if the session contains an activity class. :param session: SQLAlchemy session object \"\"\" return any(isinstance(obj, self.activity_cls) for obj in session) def before_flush(self, uow, session): for obj in session: if isinstance(obj, self.activity_cls): obj.transaction = uow.current_transaction obj.calculate_target_tx_id() obj.calculate_object_tx_id() def after_version_class_built(self, parent_cls, version_cls): pass","title":"ActivityPlugin"},{"location":"plugins/#sqlalchemy_history.plugins.activity.ActivityPlugin.is_session_modified","text":"Return that the session has been modified if the session contains an activity class. Parameters: session \u2013 SQLAlchemy session object sqlalchemy_history/plugins/activity.py def is_session_modified(self, session): \"\"\"Return that the session has been modified if the session contains an activity class. :param session: SQLAlchemy session object \"\"\" return any(isinstance(obj, self.activity_cls) for obj in session)","title":"is_session_modified()"},{"location":"plugins/#propertymodtracker","text":"The PropertyModTrackerPlugin offers a way of efficiently tracking individual property modifications. With PropertyModTrackerPlugin you can make efficient queries such as: Find all versions of model X where user updated the property A or property B. Find all versions of model X where user didn't update property A. PropertyModTrackerPlugin adds separate modified tracking column for each versioned column. So for example if you have versioned model called Article with columns name and content , this plugin would add two additional boolean columns name_mod and content_mod for the version model. When user commits transactions the plugin automatically updates these boolean columns.","title":"PropertyModTracker"},{"location":"plugins/#transactionchanges","text":"TransactionChanges provides way of keeping track efficiently which declarative models were changed in given transaction. This can be useful when transactions need to be queried afterwards for problems such as: Find all transactions which affected User model. Find all transactions which didn't affect models Entity and Event . The plugin works in two ways. On class instrumentation phase this plugin creates a special transaction model called TransactionChanges . This model is associated with table called transaction_changes , which has only only two fields: transaction_id and entity_name. If for example transaction consisted of saving 5 new User entities and 1 Article entity, two new rows would be inserted into transaction_changes table. ================ ================= transaction_id entity_name ---------------- ----------------- 233678 User 233678 Article ================ =================","title":"TransactionChanges"},{"location":"plugins/#sqlalchemy_history.plugins.transaction_changes.TransactionChangesFactory","text":"Bases: ModelFactory Source code in sqlalchemy_history/plugins/transaction_changes.py class TransactionChangesFactory(ModelFactory): model_name = \"TransactionChanges\" def create_class(self, manager): \"\"\"Create TransactionChanges class. :param manager: \"\"\" class TransactionChanges(manager.declarative_base, TransactionChangesBase): __tablename__ = \"transaction_changes\" TransactionChanges.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref( \"changes\", ), primaryjoin=(\"%s.id == TransactionChanges.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[TransactionChanges.transaction_id], ) return TransactionChanges","title":"TransactionChangesFactory"},{"location":"plugins/#sqlalchemy_history.plugins.transaction_changes.TransactionChangesFactory.create_class","text":"Create TransactionChanges class. Parameters: manager \u2013 sqlalchemy_history/plugins/transaction_changes.py def create_class(self, manager): \"\"\"Create TransactionChanges class. :param manager: \"\"\" class TransactionChanges(manager.declarative_base, TransactionChangesBase): __tablename__ = \"transaction_changes\" TransactionChanges.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref( \"changes\", ), primaryjoin=(\"%s.id == TransactionChanges.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[TransactionChanges.transaction_id], ) return TransactionChanges","title":"create_class()"},{"location":"plugins/#transactionmeta","text":"TransactionMetaPlugin offers a way of saving key-value data for transations. You can use the plugin in same way as other plugins:: meta_plugin = TransactionMetaPlugin() versioning_manager.plugins.add(meta_plugin) TransactionMetaPlugin creates a simple model called TransactionMeta. This class has three columns: transaction_id, key and value. TransactionMeta plugin also creates an association proxy between TransactionMeta and Transaction classes for easy dictionary based access of key-value pairs. You can easily 'tag' transactions with certain key value pairs by giving these keys and values to the meta property of Transaction class. :: from sqlalchemy_history import versioning_manager article = Article() session.add(article) uow = versioning_manager.unit_of_work(session) tx = uow.create_transaction(session) tx.meta = {u'some_key': u'some value'} session.commit() TransactionMeta = meta_plugin.model_class Transaction = versioning_manager.transaction_cls # find all transactions with 'article' tags query = ( session.query(Transaction) .join(Transaction.meta_relation) .filter( db.and_( TransactionMeta.key == 'some_key', TransactionMeta.value == 'some value' ) ) )","title":"TransactionMeta"},{"location":"plugins/#sqlalchemy_history.plugins.transaction_meta.TransactionMetaFactory","text":"Bases: ModelFactory Source code in sqlalchemy_history/plugins/transaction_meta.py class TransactionMetaFactory(ModelFactory): model_name = \"TransactionMeta\" def create_class(self, manager): \"\"\"Create TransactionMeta class. :param manager: \"\"\" class TransactionMeta(manager.declarative_base, TransactionMetaBase): __tablename__ = \"transaction_meta\" TransactionMeta.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref(\"meta_relation\", collection_class=attribute_mapped_collection(\"key\")), primaryjoin=(\"%s.id == TransactionMeta.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[TransactionMeta.transaction_id], ) manager.transaction_cls.meta = association_proxy( \"meta_relation\", \"value\", creator=lambda key, value: TransactionMeta(key=key, value=value), ) return TransactionMeta","title":"TransactionMetaFactory"},{"location":"plugins/#sqlalchemy_history.plugins.transaction_meta.TransactionMetaFactory.create_class","text":"Create TransactionMeta class. Parameters: manager \u2013 sqlalchemy_history/plugins/transaction_meta.py def create_class(self, manager): \"\"\"Create TransactionMeta class. :param manager: \"\"\" class TransactionMeta(manager.declarative_base, TransactionMetaBase): __tablename__ = \"transaction_meta\" TransactionMeta.transaction = sa.orm.relationship( manager.transaction_cls, backref=sa.orm.backref(\"meta_relation\", collection_class=attribute_mapped_collection(\"key\")), primaryjoin=(\"%s.id == TransactionMeta.transaction_id\" % manager.transaction_cls.__name__), foreign_keys=[TransactionMeta.transaction_id], ) manager.transaction_cls.meta = association_proxy( \"meta_relation\", \"value\", creator=lambda key, value: TransactionMeta(key=key, value=value), ) return TransactionMeta","title":"create_class()"},{"location":"queries/","text":"Queries You can query history models just like any other sqlalchemy declarative model. >>> from sqlalchemy_history import version_class >>> ArticleVersion = version_class(Article) >>> session.query(ArticleVersion).filter_by(name=u'some name').all() How many transactions have been executed? >>> from sqlalchemy_history import transaction_class >>> Transaction = transaction_class(Article) >>> Transaction.query.count() Querying for entities of a class at a given revision In the following example we find all articles which were affected by transaction 33. >>> session.query(ArticleVersion).filter_by(transaction_id=33) Querying for transactions, at which entities of a given class changed In this example we find all transactions which affected any instance of 'Article' model. This query needs the TransactionChangesPlugin. >>> TransactionChanges = Article.__versioned__['transaction_changes'] >>> entries = ( ... session.query(Transaction) ... .innerjoin(Transaction.changes) ... .filter( ... TransactionChanges.entity_name.in_(['Article']) ... ) ... ) Querying for versions of entity that modified given property In the following example we want to find all versions of Article class which changed the attribute 'name'. This example assumes you are using PropertyModTrackerPlugin. >>> ArticleVersion = version_class(Article) >>> session.query(ArticleHistory).filter(ArticleVersion.name_mod).all()","title":"Queries"},{"location":"queries/#queries","text":"You can query history models just like any other sqlalchemy declarative model. >>> from sqlalchemy_history import version_class >>> ArticleVersion = version_class(Article) >>> session.query(ArticleVersion).filter_by(name=u'some name').all()","title":"Queries"},{"location":"queries/#how-many-transactions-have-been-executed","text":">>> from sqlalchemy_history import transaction_class >>> Transaction = transaction_class(Article) >>> Transaction.query.count()","title":"How many transactions have been executed?"},{"location":"queries/#querying-for-entities-of-a-class-at-a-given-revision","text":"In the following example we find all articles which were affected by transaction 33. >>> session.query(ArticleVersion).filter_by(transaction_id=33)","title":"Querying for entities of a class at a given revision"},{"location":"queries/#querying-for-transactions-at-which-entities-of-a-given-class-changed","text":"In this example we find all transactions which affected any instance of 'Article' model. This query needs the TransactionChangesPlugin. >>> TransactionChanges = Article.__versioned__['transaction_changes'] >>> entries = ( ... session.query(Transaction) ... .innerjoin(Transaction.changes) ... .filter( ... TransactionChanges.entity_name.in_(['Article']) ... ) ... )","title":"Querying for transactions, at which entities of a given class changed"},{"location":"queries/#querying-for-versions-of-entity-that-modified-given-property","text":"In the following example we want to find all versions of Article class which changed the attribute 'name'. This example assumes you are using PropertyModTrackerPlugin. >>> ArticleVersion = version_class(Article) >>> session.query(ArticleHistory).filter(ArticleVersion.name_mod).all()","title":"Querying for versions of entity that modified given property"},{"location":"revert/","text":"Reverting changes One of the major benefits of SQLAlchemy-History is its ability to revert changes. Revert update >>> article = Article(name=u'New article', content=u'Some content') >>> session.add(article) >>> session.commit(article) >>> version = article.versions[0] >>> article.name = u'Updated article' >>> session.commit() >>> version.revert() >>> session.commit() >>> article.name 'New article' Revert delete >>> article = Article(name=u'New article', content=u'Some content') >>> session.add(article) >>> session.commit(article) >>> version = article.versions[0] >>> session.delete(article) >>> session.commit() >>> version.revert() >>> session.commit() # article lives again! >>> session.query(Article).first() Revert relationships Sometimes you may have cases where you want to revert an object as well as some of its relation to certain state. Consider the following model definition: >>> class Article(Base): ... __tablename__ = 'article' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255)) >>> class Tag(Base): ... __tablename__ = 'tag' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255)) ... article_id = sa.Column(sa.Integer, sa.ForeignKey(Article.id)) ... article = sa.orm.relationship(Article, backref='tags') Now lets say some user first adds an article with couple of tags: >>> article = Article( ... name=u'Some article', ... tags=[Tag(u'Good'), Tag(u'Interesting')] ... ) >>> session.add(article) >>> session.commit() Then lets say another user deletes one of the tags: >>> tag = session.query(Tag).filter_by(name=u'Interesting') >>> session.delete(tag) >>> session.commit() Now the first user wants to set the article back to its original state. It can be achieved as follows (notice how we use the relations parameter): >>> article = session.query(Article).get(1) >>> article.versions[0].revert(relations=['tags']) >>> session.commit()","title":"Reverting changes"},{"location":"revert/#reverting-changes","text":"One of the major benefits of SQLAlchemy-History is its ability to revert changes.","title":"Reverting changes"},{"location":"revert/#revert-update","text":">>> article = Article(name=u'New article', content=u'Some content') >>> session.add(article) >>> session.commit(article) >>> version = article.versions[0] >>> article.name = u'Updated article' >>> session.commit() >>> version.revert() >>> session.commit() >>> article.name 'New article'","title":"Revert update"},{"location":"revert/#revert-delete","text":">>> article = Article(name=u'New article', content=u'Some content') >>> session.add(article) >>> session.commit(article) >>> version = article.versions[0] >>> session.delete(article) >>> session.commit() >>> version.revert() >>> session.commit() # article lives again! >>> session.query(Article).first()","title":"Revert delete"},{"location":"revert/#revert-relationships","text":"Sometimes you may have cases where you want to revert an object as well as some of its relation to certain state. Consider the following model definition: >>> class Article(Base): ... __tablename__ = 'article' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255)) >>> class Tag(Base): ... __tablename__ = 'tag' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255)) ... article_id = sa.Column(sa.Integer, sa.ForeignKey(Article.id)) ... article = sa.orm.relationship(Article, backref='tags') Now lets say some user first adds an article with couple of tags: >>> article = Article( ... name=u'Some article', ... tags=[Tag(u'Good'), Tag(u'Interesting')] ... ) >>> session.add(article) >>> session.commit() Then lets say another user deletes one of the tags: >>> tag = session.query(Tag).filter_by(name=u'Interesting') >>> session.delete(tag) >>> session.commit() Now the first user wants to set the article back to its original state. It can be achieved as follows (notice how we use the relations parameter): >>> article = session.query(Article).get(1) >>> article.versions[0].revert(relations=['tags']) >>> session.commit()","title":"Revert relationships"},{"location":"schema/","text":"Schema Version tables By default SQLAlchemy-History creates a version table for each versioned entity table. The version tables are suffixed with 'version'. So for example if you have two versioned tables 'article' and 'category', SQLAlchemy-History would create two version tables 'articleversion' and 'categoryversion'. By default the version tables contain these columns: id of the original entity (this can be more then one column in the case of composite primary keys) transactionid - an integer that matches to the id number in the transactionlog table. endtransactionid - an integer that matches the next version record's transactionid. If this is the current version record then this field is null. operationtype - a small integer defining the type of the operation versioned fields from the original entity If you are using property-mod-tracker SQLA-History also creates one boolean field for each versioned field. By default these boolean fields are suffixed with 'mod'. The primary key of each version table is the combination of parent table's primary key + the transactionid. This means there can be at most one version table entry for a given entity instance at given transaction. Transaction tables By default SQLA-History creates one transaction table called **transaction. Many SQLA-History plugins also create additional tables for efficient transaction storage. If you wish to query efficiently transactions afterwards you should consider using some of these plugins. The transaction table only contains two fields by default: id and issuedat.","title":"Schema"},{"location":"schema/#schema","text":"","title":"Schema"},{"location":"schema/#version-tables","text":"By default SQLAlchemy-History creates a version table for each versioned entity table. The version tables are suffixed with 'version'. So for example if you have two versioned tables 'article' and 'category', SQLAlchemy-History would create two version tables 'articleversion' and 'categoryversion'. By default the version tables contain these columns: id of the original entity (this can be more then one column in the case of composite primary keys) transactionid - an integer that matches to the id number in the transactionlog table. endtransactionid - an integer that matches the next version record's transactionid. If this is the current version record then this field is null. operationtype - a small integer defining the type of the operation versioned fields from the original entity If you are using property-mod-tracker SQLA-History also creates one boolean field for each versioned field. By default these boolean fields are suffixed with 'mod'. The primary key of each version table is the combination of parent table's primary key + the transactionid. This means there can be at most one version table entry for a given entity instance at given transaction.","title":"Version tables"},{"location":"schema/#transaction-tables","text":"By default SQLA-History creates one transaction table called **transaction. Many SQLA-History plugins also create additional tables for efficient transaction storage. If you wish to query efficiently transactions afterwards you should consider using some of these plugins. The transaction table only contains two fields by default: id and issuedat.","title":"Transaction tables"},{"location":"transactions/","text":"Transactions Transaction For each committed transaction SQLAlchemy-History creates a new Transaction record. Transaction can be queried just like any other sqlalchemy declarative model. >>> from sqlalchemy_history import transaction_class >>> Transaction = transaction_class(Article) >>> session.query(Transaction).all() # find all transactions UnitOfWork For each database connection SQLAlchemy-History creates an internal UnitOfWork object. Normally these objects are created at before flush phase of session workflow. However you can also force create unit of work before this phase. >>> uow = versioning_manager.unit_of_work(session) Transaction objects are normally created automatically at before flush phase. If you need access to transaction object before the flush phase begins you can do so by calling the create_transaction method of the UnitOfWork class. >>> transaction = uow.create_transaction(session) The version objects are normally created during the after flush phase but you can also force create those at any time by calling make_versions method. >>> uow.make_versions(session) Workflow internals Consider the following code snippet where we create a new article. >>> article = Article() >>> article.name = u'Some article' >>> article.content = u'Some content' >>> session.add(article) >>> session.commit() This would execute the following SQL queries (on PostgreSQL) 1. INSERT INTO article (name, content) VALUES (?, ?) params: ('Some article', 'Some content') 2. INSERT INTO transaction (issued_at) VALUES (?) params: (datetime.utcnow()) 3. INSERT INTO article_version (id, name, content, transaction_id) VALUES (?, ?, ?, ?) params: (<article id from query 1>, 'Some article', 'Some content', <transaction id from query 2>)","title":"Transactions"},{"location":"transactions/#transactions","text":"","title":"Transactions"},{"location":"transactions/#transaction","text":"For each committed transaction SQLAlchemy-History creates a new Transaction record. Transaction can be queried just like any other sqlalchemy declarative model. >>> from sqlalchemy_history import transaction_class >>> Transaction = transaction_class(Article) >>> session.query(Transaction).all() # find all transactions","title":"Transaction"},{"location":"transactions/#unitofwork","text":"For each database connection SQLAlchemy-History creates an internal UnitOfWork object. Normally these objects are created at before flush phase of session workflow. However you can also force create unit of work before this phase. >>> uow = versioning_manager.unit_of_work(session) Transaction objects are normally created automatically at before flush phase. If you need access to transaction object before the flush phase begins you can do so by calling the create_transaction method of the UnitOfWork class. >>> transaction = uow.create_transaction(session) The version objects are normally created during the after flush phase but you can also force create those at any time by calling make_versions method. >>> uow.make_versions(session)","title":"UnitOfWork"},{"location":"transactions/#workflow-internals","text":"Consider the following code snippet where we create a new article. >>> article = Article() >>> article.name = u'Some article' >>> article.content = u'Some content' >>> session.add(article) >>> session.commit() This would execute the following SQL queries (on PostgreSQL) 1. INSERT INTO article (name, content) VALUES (?, ?) params: ('Some article', 'Some content') 2. INSERT INTO transaction (issued_at) VALUES (?) params: (datetime.utcnow()) 3. INSERT INTO article_version (id, name, content, transaction_id) VALUES (?, ?, ?, ?) params: (<article id from query 1>, 'Some article', 'Some content', <transaction id from query 2>)","title":"Workflow internals"},{"location":"tutorials/","text":"Tutorial Modules exported by this package: make_versioned : This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. remove_versioning : Remove the versioning from given mapper / session and manager. make_versioned(mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager, plugins=None, options=None, user_cls='User') This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. By default this applies to all mappers and all sessions. Examples >>> make_versioned(user_cls=None, options={'table_name': '%_tracker'}) None Parameters: mapper ( sa.orm.Mapper , default: sa . orm . Mapper ) \u2013 SQLAlchemy mapper to apply the versioning to. (Default value = sa.orm.Mapper) session \u2013 SQLAlchemy session to apply the versioning to. By default this is sa.orm.session.Session meaning it applies to all Session subclasses. manager ( VersioningManager , default: versioning_manager ) \u2013 SQLAlchemy-History versioning manager. (Default value = versioning_manager) plugins \u2013 Plugins to pass for versioning manager. (Default value = None) options ( dict , default: None ) \u2013 A dictionary of VersioningManager options. (Default value = None) user_cls \u2013 User class which the Transaction class should have relationship to. This can either be a class or string name of a class for lazy evaluation. (Default value = \"User\") Returns: NoneType \u2013 None sqlalchemy_history/__init__.py def make_versioned( mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager, plugins=None, options=None, user_cls=\"User\", ): \"\"\"This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. By default this applies to all mappers and all sessions. **Examples** >>> make_versioned(user_cls=None, options={'table_name': '%_tracker'}) None :param mapper: SQLAlchemy mapper to apply the versioning to. (Default value = sa.orm.Mapper) :type mapper: sa.orm.Mapper :param session: SQLAlchemy session to apply the versioning to. By default this is sa.orm.session.Session meaning it applies to all Session subclasses. :param manager: SQLAlchemy-History versioning manager. (Default value = versioning_manager) :type manager: VersioningManager :param plugins: Plugins to pass for versioning manager. (Default value = None) :param options: A dictionary of VersioningManager options. (Default value = None) :type options: dict :param user_cls: User class which the Transaction class should have relationship to. This can either be a class or string name of a class for lazy evaluation. (Default value = \"User\") :returns: None :rtype: NoneType \"\"\" if plugins is not None: manager.plugins = plugins if options is not None: manager.options.update(options) manager.user_cls = user_cls manager.apply_class_configuration_listeners(mapper) manager.track_operations(mapper) manager.track_session(session) sa.event.listen(sa.engine.Engine, \"before_cursor_execute\", manager.track_sql_operations) sa.event.listen(sa.engine.Engine, \"rollback\", manager.clear_connection) sa.event.listen( sa.engine.Engine, \"set_connection_execution_options\", manager.track_cloned_connections, ) remove_versioning(mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager) Remove the versioning from given mapper / session and manager. Examples >>> remove_versioning() None Parameters: mapper ( sa.orm.Mapper , default: sa . orm . Mapper ) \u2013 SQLAlchemy mapper to remove the versioning from. (Default value = sa.orm.Mapper) session \u2013 SQLAlchemy session to remove the versioning from. By default this is sa.orm.session.Session meaning it applies to all sessions. (Default value = sa.orm.session.Session) manager ( VersioningManager , default: versioning_manager ) \u2013 SQLAlchemy-History versioning manager. (Default value = versioning_manager) Returns: NoneType \u2013 None sqlalchemy_history/__init__.py def remove_versioning(mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager): \"\"\"Remove the versioning from given mapper / session and manager. **Examples** >>> remove_versioning() None :param mapper: SQLAlchemy mapper to remove the versioning from. (Default value = sa.orm.Mapper) :type mapper: sa.orm.Mapper :param session: SQLAlchemy session to remove the versioning from. By default this is sa.orm.session.Session meaning it applies to all sessions. (Default value = sa.orm.session.Session) :param manager: SQLAlchemy-History versioning manager. (Default value = versioning_manager) :type manager: VersioningManager :returns: None :rtype: NoneType \"\"\" manager.reset() manager.remove_class_configuration_listeners(mapper) manager.remove_operations_tracking(mapper) manager.remove_session_tracking(session) sa.event.remove(sa.engine.Engine, \"before_cursor_execute\", manager.track_sql_operations) sa.event.remove(sa.engine.Engine, \"rollback\", manager.clear_connection) sa.event.remove( sa.engine.Engine, \"set_connection_execution_options\", manager.track_cloned_connections, )","title":"Tutorial"},{"location":"tutorials/#tutorial","text":"Modules exported by this package: make_versioned : This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. remove_versioning : Remove the versioning from given mapper / session and manager.","title":"Tutorial"},{"location":"tutorials/#sqlalchemy_history.make_versioned","text":"This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. By default this applies to all mappers and all sessions. Examples >>> make_versioned(user_cls=None, options={'table_name': '%_tracker'}) None Parameters: mapper ( sa.orm.Mapper , default: sa . orm . Mapper ) \u2013 SQLAlchemy mapper to apply the versioning to. (Default value = sa.orm.Mapper) session \u2013 SQLAlchemy session to apply the versioning to. By default this is sa.orm.session.Session meaning it applies to all Session subclasses. manager ( VersioningManager , default: versioning_manager ) \u2013 SQLAlchemy-History versioning manager. (Default value = versioning_manager) plugins \u2013 Plugins to pass for versioning manager. (Default value = None) options ( dict , default: None ) \u2013 A dictionary of VersioningManager options. (Default value = None) user_cls \u2013 User class which the Transaction class should have relationship to. This can either be a class or string name of a class for lazy evaluation. (Default value = \"User\") Returns: NoneType \u2013 None sqlalchemy_history/__init__.py def make_versioned( mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager, plugins=None, options=None, user_cls=\"User\", ): \"\"\"This is the public API function of SQLAlchemy-History for making certain mappers and sessions versioned. By default this applies to all mappers and all sessions. **Examples** >>> make_versioned(user_cls=None, options={'table_name': '%_tracker'}) None :param mapper: SQLAlchemy mapper to apply the versioning to. (Default value = sa.orm.Mapper) :type mapper: sa.orm.Mapper :param session: SQLAlchemy session to apply the versioning to. By default this is sa.orm.session.Session meaning it applies to all Session subclasses. :param manager: SQLAlchemy-History versioning manager. (Default value = versioning_manager) :type manager: VersioningManager :param plugins: Plugins to pass for versioning manager. (Default value = None) :param options: A dictionary of VersioningManager options. (Default value = None) :type options: dict :param user_cls: User class which the Transaction class should have relationship to. This can either be a class or string name of a class for lazy evaluation. (Default value = \"User\") :returns: None :rtype: NoneType \"\"\" if plugins is not None: manager.plugins = plugins if options is not None: manager.options.update(options) manager.user_cls = user_cls manager.apply_class_configuration_listeners(mapper) manager.track_operations(mapper) manager.track_session(session) sa.event.listen(sa.engine.Engine, \"before_cursor_execute\", manager.track_sql_operations) sa.event.listen(sa.engine.Engine, \"rollback\", manager.clear_connection) sa.event.listen( sa.engine.Engine, \"set_connection_execution_options\", manager.track_cloned_connections, )","title":"make_versioned()"},{"location":"tutorials/#sqlalchemy_history.remove_versioning","text":"Remove the versioning from given mapper / session and manager. Examples >>> remove_versioning() None Parameters: mapper ( sa.orm.Mapper , default: sa . orm . Mapper ) \u2013 SQLAlchemy mapper to remove the versioning from. (Default value = sa.orm.Mapper) session \u2013 SQLAlchemy session to remove the versioning from. By default this is sa.orm.session.Session meaning it applies to all sessions. (Default value = sa.orm.session.Session) manager ( VersioningManager , default: versioning_manager ) \u2013 SQLAlchemy-History versioning manager. (Default value = versioning_manager) Returns: NoneType \u2013 None sqlalchemy_history/__init__.py def remove_versioning(mapper=sa.orm.Mapper, session=sa.orm.session.Session, manager=versioning_manager): \"\"\"Remove the versioning from given mapper / session and manager. **Examples** >>> remove_versioning() None :param mapper: SQLAlchemy mapper to remove the versioning from. (Default value = sa.orm.Mapper) :type mapper: sa.orm.Mapper :param session: SQLAlchemy session to remove the versioning from. By default this is sa.orm.session.Session meaning it applies to all sessions. (Default value = sa.orm.session.Session) :param manager: SQLAlchemy-History versioning manager. (Default value = versioning_manager) :type manager: VersioningManager :returns: None :rtype: NoneType \"\"\" manager.reset() manager.remove_class_configuration_listeners(mapper) manager.remove_operations_tracking(mapper) manager.remove_session_tracking(session) sa.event.remove(sa.engine.Engine, \"before_cursor_execute\", manager.track_sql_operations) sa.event.remove(sa.engine.Engine, \"rollback\", manager.clear_connection) sa.event.remove( sa.engine.Engine, \"set_connection_execution_options\", manager.track_cloned_connections, )","title":"remove_versioning()"},{"location":"utilities/","text":"Utilities changeset(obj) Return a humanized changeset for given SQLAlchemy declarative object. With this function you can easily check the changeset of given object in current transaction. Parameters: obj \u2013 Returns: \u2013 this function you can easily check the changeset of given object in current transaction. sqlalchemy_history/utils.py def changeset(obj): \"\"\" Return a humanized changeset for given SQLAlchemy declarative object. With this function you can easily check the changeset of given object in current transaction. :param obj: :returns: this function you can easily check the changeset of given object in current transaction. \"\"\" data = {} session = sa.orm.object_session(obj) if session and obj in session.deleted: columns = [c for c in sa.inspect(obj.__class__).columns.values() if is_table_column(c)] for column in columns: if not column.primary_key: value = getattr(obj, column.key) if value is not None: data[column.key] = [None, getattr(obj, column.key)] else: for prop in obj.__mapper__.iterate_properties: history = get_history(obj, prop.key) if history.has_changes(): old_value = history.deleted[0] if history.deleted else None new_value = history.added[0] if history.added else None if new_value: data[prop.key] = [new_value, old_value] return data count_versions(obj) Return the number of versions given object has. This function works even when obj has create_models and create_tables versioned settings Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 when obj has create_models and create_tables versioned settings disabled. sqlalchemy_history/utils.py def count_versions(obj): \"\"\" Return the number of versions given object has. This function works even when obj has `create_models` and `create_tables` versioned settings :param obj: SQLAlchemy declarative model object :returns: when obj has `create_models` and `create_tables` versioned settings disabled. \"\"\" session = sa.orm.object_session(obj) if session is None: # If object is transient, we assume it has no version history. return 0 manager = get_versioning_manager(obj) table_name = manager.option(obj, \"table_name\") % obj.__table__.name criteria = [\"%s = %r\" % (pk, getattr(obj, pk)) for pk in get_primary_keys(obj)] query = sa.text(\"SELECT COUNT(1) FROM %s WHERE %s\" % (table_name, \" AND \".join(criteria))) return session.execute(query).scalar() get_association_proxies(klass) Get Association proxy mappings for ORM Models sqlalchemy_history/utils.py def get_association_proxies(klass): \"\"\"Get Association proxy mappings for ORM Models\"\"\" # NOTE: Ideally this method we should try to move it to sqlalchemy-utils # if they are ok with it as they provide a similar method to detect and # provide hypbrid properties. # ref: https://github.com/kvesteri/sqlalchemy-utils/issues/679 association_proxy_mapping = {} for key, prop in sa.inspect(klass).all_orm_descriptors.items(): if isinstance(prop, sa.ext.associationproxy.AssociationProxy): association_proxy_mapping[key] = prop return association_proxy_mapping get_versioning_manager(item) Return the associated SQLAlchemy-History VersioningManager for given SQLAlchemy declarative model class or object or table. Parameters: item \u2013 An item from SQLAlchemy A \u2013 declarative ORM object An \u2013 instance of a SQL table Returns: \u2013 SQLAlchemy declarative model class or object or table. sqlalchemy_history/utils.py def get_versioning_manager(item): \"\"\" Return the associated SQLAlchemy-History VersioningManager for given SQLAlchemy declarative model class or object or table. :param item: An item from SQLAlchemy :param A: declarative ORM object :param A: declarative ORM class :param An: instance of a SQL table :returns: SQLAlchemy declarative model class or object or table. \"\"\" # The ORM class or SQL table on which versioning was enabled versioned_item = None if isclass(item): versioned_item = item else: if isinstance(item, AliasedClass): versioned_item = sa.inspect(item).mapper.class_ elif isinstance(item, sa.Table): versioned_item = item else: versioned_item = item.__class__ try: return versioned_item.__versioning_manager__ except AttributeError: if isinstance(versioned_item, sa.Table): raise TableNotVersioned('Table \"%s\"' % versioned_item.name) else: raise ClassNotVersioned(versioned_item.__name__) is_internal_column(model, column_name) Return whether or not given column of given SQLAlchemy declarative classs is considered an internal column (a column whose purpose is mainly for SQLA-History's internal use). Parameters: version_obj \u2013 SQLAlchemy declarative class column_name \u2013 Name of the column model \u2013 Returns: \u2013 Bool sqlalchemy_history/utils.py def is_internal_column(model, column_name): \"\"\" Return whether or not given column of given SQLAlchemy declarative classs is considered an internal column (a column whose purpose is mainly for SQLA-History's internal use). :param version_obj: SQLAlchemy declarative class :param column_name: Name of the column :param model: :returns: Bool \"\"\" return column_name in ( option(model, \"transaction_column_name\"), option(model, \"end_transaction_column_name\"), option(model, \"operation_type_column_name\"), ) is_modified(obj) Return whether or not the versioned properties of given object have been modified. Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 modified. sqlalchemy_history/utils.py def is_modified(obj): \"\"\" Return whether or not the versioned properties of given object have been modified. :param obj: SQLAlchemy declarative model object :returns: modified. \"\"\" column_names = sa.inspect(obj.__class__).columns.keys() versioned_column_keys = [prop.key for prop in versioned_column_properties(obj)] versioned_relationship_keys = [prop.key for prop in versioned_relationships(obj, versioned_column_keys)] for key, attr in sa.inspect(obj).attrs.items(): if key in column_names: if key not in versioned_column_keys: continue if attr.history.has_changes(): return True if key in versioned_relationship_keys: if attr.history.has_changes(): return True return False is_modified_or_deleted(obj) Return whether or not some of the versioned properties of given SQLAlchemy declarative object have been modified or if the object has been deleted. Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 Bool sqlalchemy_history/utils.py def is_modified_or_deleted(obj): \"\"\" Return whether or not some of the versioned properties of given SQLAlchemy declarative object have been modified or if the object has been deleted. :param obj: SQLAlchemy declarative model object :returns: Bool \"\"\" session = sa.orm.object_session(obj) return is_versioned(obj) and (is_modified(obj) or obj in chain(session.deleted, session.new)) is_session_modified(session) Return whether or not any of the versioned objects in given session have been either modified or deleted. Parameters: session \u2013 SQLAlchemy session object Returns: \u2013 Bool sqlalchemy_history/utils.py def is_session_modified(session): \"\"\"Return whether or not any of the versioned objects in given session have been either modified or deleted. :param session: SQLAlchemy session object :returns: Bool \"\"\" return any(is_modified_or_deleted(obj) for obj in versioned_objects(session)) is_table_column(column) Return wheter of not give field is a column over the database table. Parameters: column \u2013 SQLAclhemy model field Returns: \u2013 Bool sqlalchemy_history/utils.py def is_table_column(column): \"\"\" Return wheter of not give field is a column over the database table. :param column: SQLAclhemy model field :returns: Bool \"\"\" return isinstance(column, sa.Column) is_versioned(obj_or_class) Return whether or not given object is versioned. Parameters: obj_or_class \u2013 SQLAlchemy \u2013 declarative model object or SQLAlchemy declarative model class \u2013 seealso \u2013 func Returns: \u2013 sqlalchemy_history/utils.py def is_versioned(obj_or_class): \"\"\" Return whether or not given object is versioned. :param obj_or_class: :param SQLAlchemy: declarative model object or SQLAlchemy declarative model :param class: :param seealso: func :returns: \"\"\" try: return hasattr(obj_or_class, \"__versioned__\") and get_versioning_manager(obj_or_class).option( obj_or_class, \"versioning\" ) except ClassNotVersioned: return False option(obj_or_class, option_name) Return the option value of given option for given versioned object or class. Parameters: obj_or_class \u2013 SQLAlchemy declarative model object or class option_name \u2013 The name of an option to return sqlalchemy_history/utils.py def option(obj_or_class, option_name): \"\"\"Return the option value of given option for given versioned object or class. :param obj_or_class: SQLAlchemy declarative model object or class :param option_name: The name of an option to return \"\"\" if isinstance(obj_or_class, AliasedClass): obj_or_class = sa.inspect(obj_or_class).mapper.class_ cls = obj_or_class if isclass(obj_or_class) else obj_or_class.__class__ if not hasattr(cls, \"__versioned__\"): cls = parent_class(cls) return get_versioning_manager(cls).option(cls, option_name) parent_class(version_cls) Return the parent class for given version model class. Parameters: model \u2013 SQLAlchemy declarative version model class version_cls \u2013 Returns: \u2013 sqlalchemy_history/utils.py def parent_class(version_cls): \"\"\" Return the parent class for given version model class. :param model: SQLAlchemy declarative version model class :param version_cls: :returns: \"\"\" manager = get_versioning_manager(version_cls) try: return next((k for k, v in manager.version_class_map.items() if v == version_cls)) except StopIteration: # Should raise Key Error if we can't find the parent_object of a orphaned versioned_model raise KeyError(version_cls) parent_table(version_table) Return corresponding parent table for any given parent table. Parameters: version_table \u2013 A versioned table table which could be either association_table or model_table. sqlalchemy_history/utils.py def parent_table(version_table): \"\"\" Return corresponding parent table for any given parent table. :param version_table: A versioned table table which could be either association_table or model_table. \"\"\" manager = get_versioning_manager(version_table) try: return next((k for k, v in manager.version_table_map.items() if v == version_table)) except StopIteration: # Raise Key error as we couldn't find parent_object of versioned_object raise KeyError(version_table) transaction_class(cls) Return the associated transaction class for given versioned SQLAlchemy declarative class or version class. Parameters: cls \u2013 SQLAlchemy versioned declarative class or version model class Returns: \u2013 declarative class or version class. sqlalchemy_history/utils.py def transaction_class(cls): \"\"\" Return the associated transaction class for given versioned SQLAlchemy declarative class or version class. :param cls: SQLAlchemy versioned declarative class or version model class :returns: declarative class or version class. \"\"\" return get_versioning_manager(cls).transaction_cls vacuum(session, model, yield_per=1000) When making structural changes to version tables (for example dropping columns) there are sometimes situations where some old version records become futile. Vacuum deletes all futile version rows which had no changes compared to previous version. Parameters: session \u2013 SQLAlchemy session object model \u2013 SQLAlchemy declarative model class yield_per \u2013 how many rows to process at a time (Default value = 1000) sqlalchemy_history/utils.py def vacuum(session, model, yield_per=1000): \"\"\"When making structural changes to version tables (for example dropping columns) there are sometimes situations where some old version records become futile. Vacuum deletes all futile version rows which had no changes compared to previous version. :param session: SQLAlchemy session object :param model: SQLAlchemy declarative model class :param yield_per: how many rows to process at a time (Default value = 1000) \"\"\" version_cls = version_class(model) versions = defaultdict(list) query = (session.query(version_cls).order_by(option(version_cls, \"transaction_column_name\"))).yield_per( yield_per ) primary_key_col = sa.inspection.inspect(model).primary_key[0].name for version in query: version_id = getattr(version, primary_key_col) if versions[version_id]: prev_version = versions[version_id][-1] if naturally_equivalent(prev_version, version): session.delete(version) else: versions[version_id].append(version) version_class(model) Return the version class for given SQLAlchemy declarative model class. Parameters: model \u2013 SQLAlchemy declarative model class Returns: \u2013 sqlalchemy_history/utils.py def version_class(model): \"\"\" Return the version class for given SQLAlchemy declarative model class. :param model: SQLAlchemy declarative model class :returns: \"\"\" manager = get_versioning_manager(model) return manager.version_class_map.get(model, None) version_table(table) Return associated version table for given SQLAlchemy Table object. Parameters: table \u2013 SQLAlchemy Table object sqlalchemy_history/utils.py def version_table(table): \"\"\" Return associated version table for given SQLAlchemy Table object. :param table: SQLAlchemy Table object \"\"\" manager = get_versioning_manager(table) return manager.version_table_map.get(table, None) versioned_column_properties(obj_or_class) Parameters: obj \u2013 SQLAlchemy declarative model object obj_or_class \u2013 Returns: \u2013 declarative model object. sqlalchemy_history/utils.py def versioned_column_properties(obj_or_class): \"\"\" :param obj: SQLAlchemy declarative model object :param obj_or_class: :returns: declarative model object. \"\"\" manager = get_versioning_manager(obj_or_class) cls = obj_or_class if isclass(obj_or_class) else obj_or_class.__class__ mapper = sa.inspect(cls) for key, column in mapper.columns.items(): # Ignores non table columns if not is_table_column(column): continue if not manager.is_excluded_property(obj_or_class, key): yield getattr(mapper.attrs, key) versioned_objects(session) Return all versioned objects in given session. Parameters: session \u2013 SQLAlchemy session object sqlalchemy_history/utils.py def versioned_objects(session): \"\"\" Return all versioned objects in given session. :param session: SQLAlchemy session object \"\"\" for obj in session: if is_versioned(obj): yield obj versioned_relationships(obj, versioned_column_keys) Parameters: obj \u2013 SQLAlchemy declarative model object versioned_column_keys \u2013 Returns: \u2013 declarative model object. sqlalchemy_history/utils.py def versioned_relationships(obj, versioned_column_keys): \"\"\" :param obj: SQLAlchemy declarative model object :param versioned_column_keys: :returns: declarative model object. \"\"\" for prop in sa.inspect(obj.__class__).relationships: if any(c.key in versioned_column_keys for c in prop.local_columns): yield prop changeset Return a humanized changeset for given SQLAlchemy declarative object. With this function you can easily check the changeset of given object in current transaction. Parameters: obj \u2013 Returns: \u2013 this function you can easily check the changeset of given object in current transaction. sqlalchemy_history/utils.py def changeset(obj): \"\"\" Return a humanized changeset for given SQLAlchemy declarative object. With this function you can easily check the changeset of given object in current transaction. :param obj: :returns: this function you can easily check the changeset of given object in current transaction. \"\"\" data = {} session = sa.orm.object_session(obj) if session and obj in session.deleted: columns = [c for c in sa.inspect(obj.__class__).columns.values() if is_table_column(c)] for column in columns: if not column.primary_key: value = getattr(obj, column.key) if value is not None: data[column.key] = [None, getattr(obj, column.key)] else: for prop in obj.__mapper__.iterate_properties: history = get_history(obj, prop.key) if history.has_changes(): old_value = history.deleted[0] if history.deleted else None new_value = history.added[0] if history.added else None if new_value: data[prop.key] = [new_value, old_value] return data count_versions Return the number of versions given object has. This function works even when obj has create_models and create_tables versioned settings Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 when obj has create_models and create_tables versioned settings disabled. sqlalchemy_history/utils.py def count_versions(obj): \"\"\" Return the number of versions given object has. This function works even when obj has `create_models` and `create_tables` versioned settings :param obj: SQLAlchemy declarative model object :returns: when obj has `create_models` and `create_tables` versioned settings disabled. \"\"\" session = sa.orm.object_session(obj) if session is None: # If object is transient, we assume it has no version history. return 0 manager = get_versioning_manager(obj) table_name = manager.option(obj, \"table_name\") % obj.__table__.name criteria = [\"%s = %r\" % (pk, getattr(obj, pk)) for pk in get_primary_keys(obj)] query = sa.text(\"SELECT COUNT(1) FROM %s WHERE %s\" % (table_name, \" AND \".join(criteria))) return session.execute(query).scalar() get_versioning_manager Return the associated SQLAlchemy-History VersioningManager for given SQLAlchemy declarative model class or object or table. Parameters: item \u2013 An item from SQLAlchemy A \u2013 declarative ORM object An \u2013 instance of a SQL table Returns: \u2013 SQLAlchemy declarative model class or object or table. sqlalchemy_history/utils.py def get_versioning_manager(item): \"\"\" Return the associated SQLAlchemy-History VersioningManager for given SQLAlchemy declarative model class or object or table. :param item: An item from SQLAlchemy :param A: declarative ORM object :param A: declarative ORM class :param An: instance of a SQL table :returns: SQLAlchemy declarative model class or object or table. \"\"\" # The ORM class or SQL table on which versioning was enabled versioned_item = None if isclass(item): versioned_item = item else: if isinstance(item, AliasedClass): versioned_item = sa.inspect(item).mapper.class_ elif isinstance(item, sa.Table): versioned_item = item else: versioned_item = item.__class__ try: return versioned_item.__versioning_manager__ except AttributeError: if isinstance(versioned_item, sa.Table): raise TableNotVersioned('Table \"%s\"' % versioned_item.name) else: raise ClassNotVersioned(versioned_item.__name__) is_modified Return whether or not the versioned properties of given object have been modified. Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 modified. sqlalchemy_history/utils.py def is_modified(obj): \"\"\" Return whether or not the versioned properties of given object have been modified. :param obj: SQLAlchemy declarative model object :returns: modified. \"\"\" column_names = sa.inspect(obj.__class__).columns.keys() versioned_column_keys = [prop.key for prop in versioned_column_properties(obj)] versioned_relationship_keys = [prop.key for prop in versioned_relationships(obj, versioned_column_keys)] for key, attr in sa.inspect(obj).attrs.items(): if key in column_names: if key not in versioned_column_keys: continue if attr.history.has_changes(): return True if key in versioned_relationship_keys: if attr.history.has_changes(): return True return False is_modified_or_deleted Return whether or not some of the versioned properties of given SQLAlchemy declarative object have been modified or if the object has been deleted. Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 Bool sqlalchemy_history/utils.py def is_modified_or_deleted(obj): \"\"\" Return whether or not some of the versioned properties of given SQLAlchemy declarative object have been modified or if the object has been deleted. :param obj: SQLAlchemy declarative model object :returns: Bool \"\"\" session = sa.orm.object_session(obj) return is_versioned(obj) and (is_modified(obj) or obj in chain(session.deleted, session.new)) is_session_modified Return whether or not any of the versioned objects in given session have been either modified or deleted. Parameters: session \u2013 SQLAlchemy session object Returns: \u2013 Bool sqlalchemy_history/utils.py def is_session_modified(session): \"\"\"Return whether or not any of the versioned objects in given session have been either modified or deleted. :param session: SQLAlchemy session object :returns: Bool \"\"\" return any(is_modified_or_deleted(obj) for obj in versioned_objects(session)) is_versioned Return whether or not given object is versioned. Parameters: obj_or_class \u2013 SQLAlchemy \u2013 declarative model object or SQLAlchemy declarative model class \u2013 seealso \u2013 func Returns: \u2013 sqlalchemy_history/utils.py def is_versioned(obj_or_class): \"\"\" Return whether or not given object is versioned. :param obj_or_class: :param SQLAlchemy: declarative model object or SQLAlchemy declarative model :param class: :param seealso: func :returns: \"\"\" try: return hasattr(obj_or_class, \"__versioned__\") and get_versioning_manager(obj_or_class).option( obj_or_class, \"versioning\" ) except ClassNotVersioned: return False parent_class Return the parent class for given version model class. Parameters: model \u2013 SQLAlchemy declarative version model class version_cls \u2013 Returns: \u2013 sqlalchemy_history/utils.py def parent_class(version_cls): \"\"\" Return the parent class for given version model class. :param model: SQLAlchemy declarative version model class :param version_cls: :returns: \"\"\" manager = get_versioning_manager(version_cls) try: return next((k for k, v in manager.version_class_map.items() if v == version_cls)) except StopIteration: # Should raise Key Error if we can't find the parent_object of a orphaned versioned_model raise KeyError(version_cls) transaction_class Return the associated transaction class for given versioned SQLAlchemy declarative class or version class. Parameters: cls \u2013 SQLAlchemy versioned declarative class or version model class Returns: \u2013 declarative class or version class. sqlalchemy_history/utils.py def transaction_class(cls): \"\"\" Return the associated transaction class for given versioned SQLAlchemy declarative class or version class. :param cls: SQLAlchemy versioned declarative class or version model class :returns: declarative class or version class. \"\"\" return get_versioning_manager(cls).transaction_cls version_class Return the version class for given SQLAlchemy declarative model class. Parameters: model \u2013 SQLAlchemy declarative model class Returns: \u2013 sqlalchemy_history/utils.py def version_class(model): \"\"\" Return the version class for given SQLAlchemy declarative model class. :param model: SQLAlchemy declarative model class :returns: \"\"\" manager = get_versioning_manager(model) return manager.version_class_map.get(model, None) versioned_objects Return all versioned objects in given session. Parameters: session \u2013 SQLAlchemy session object sqlalchemy_history/utils.py def versioned_objects(session): \"\"\" Return all versioned objects in given session. :param session: SQLAlchemy session object \"\"\" for obj in session: if is_versioned(obj): yield obj version_table Return associated version table for given SQLAlchemy Table object. Parameters: table \u2013 SQLAlchemy Table object sqlalchemy_history/utils.py def version_table(table): \"\"\" Return associated version table for given SQLAlchemy Table object. :param table: SQLAlchemy Table object \"\"\" manager = get_versioning_manager(table) return manager.version_table_map.get(table, None)","title":"Utilities"},{"location":"utilities/#utilities","text":"","title":"Utilities"},{"location":"utilities/#sqlalchemy_history.utils.changeset","text":"Return a humanized changeset for given SQLAlchemy declarative object. With this function you can easily check the changeset of given object in current transaction. Parameters: obj \u2013 Returns: \u2013 this function you can easily check the changeset of given object in current transaction. sqlalchemy_history/utils.py def changeset(obj): \"\"\" Return a humanized changeset for given SQLAlchemy declarative object. With this function you can easily check the changeset of given object in current transaction. :param obj: :returns: this function you can easily check the changeset of given object in current transaction. \"\"\" data = {} session = sa.orm.object_session(obj) if session and obj in session.deleted: columns = [c for c in sa.inspect(obj.__class__).columns.values() if is_table_column(c)] for column in columns: if not column.primary_key: value = getattr(obj, column.key) if value is not None: data[column.key] = [None, getattr(obj, column.key)] else: for prop in obj.__mapper__.iterate_properties: history = get_history(obj, prop.key) if history.has_changes(): old_value = history.deleted[0] if history.deleted else None new_value = history.added[0] if history.added else None if new_value: data[prop.key] = [new_value, old_value] return data","title":"changeset()"},{"location":"utilities/#sqlalchemy_history.utils.count_versions","text":"Return the number of versions given object has. This function works even when obj has create_models and create_tables versioned settings Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 when obj has create_models and create_tables versioned settings disabled. sqlalchemy_history/utils.py def count_versions(obj): \"\"\" Return the number of versions given object has. This function works even when obj has `create_models` and `create_tables` versioned settings :param obj: SQLAlchemy declarative model object :returns: when obj has `create_models` and `create_tables` versioned settings disabled. \"\"\" session = sa.orm.object_session(obj) if session is None: # If object is transient, we assume it has no version history. return 0 manager = get_versioning_manager(obj) table_name = manager.option(obj, \"table_name\") % obj.__table__.name criteria = [\"%s = %r\" % (pk, getattr(obj, pk)) for pk in get_primary_keys(obj)] query = sa.text(\"SELECT COUNT(1) FROM %s WHERE %s\" % (table_name, \" AND \".join(criteria))) return session.execute(query).scalar()","title":"count_versions()"},{"location":"utilities/#sqlalchemy_history.utils.get_association_proxies","text":"Get Association proxy mappings for ORM Models sqlalchemy_history/utils.py def get_association_proxies(klass): \"\"\"Get Association proxy mappings for ORM Models\"\"\" # NOTE: Ideally this method we should try to move it to sqlalchemy-utils # if they are ok with it as they provide a similar method to detect and # provide hypbrid properties. # ref: https://github.com/kvesteri/sqlalchemy-utils/issues/679 association_proxy_mapping = {} for key, prop in sa.inspect(klass).all_orm_descriptors.items(): if isinstance(prop, sa.ext.associationproxy.AssociationProxy): association_proxy_mapping[key] = prop return association_proxy_mapping","title":"get_association_proxies()"},{"location":"utilities/#sqlalchemy_history.utils.get_versioning_manager","text":"Return the associated SQLAlchemy-History VersioningManager for given SQLAlchemy declarative model class or object or table. Parameters: item \u2013 An item from SQLAlchemy A \u2013 declarative ORM object An \u2013 instance of a SQL table Returns: \u2013 SQLAlchemy declarative model class or object or table. sqlalchemy_history/utils.py def get_versioning_manager(item): \"\"\" Return the associated SQLAlchemy-History VersioningManager for given SQLAlchemy declarative model class or object or table. :param item: An item from SQLAlchemy :param A: declarative ORM object :param A: declarative ORM class :param An: instance of a SQL table :returns: SQLAlchemy declarative model class or object or table. \"\"\" # The ORM class or SQL table on which versioning was enabled versioned_item = None if isclass(item): versioned_item = item else: if isinstance(item, AliasedClass): versioned_item = sa.inspect(item).mapper.class_ elif isinstance(item, sa.Table): versioned_item = item else: versioned_item = item.__class__ try: return versioned_item.__versioning_manager__ except AttributeError: if isinstance(versioned_item, sa.Table): raise TableNotVersioned('Table \"%s\"' % versioned_item.name) else: raise ClassNotVersioned(versioned_item.__name__)","title":"get_versioning_manager()"},{"location":"utilities/#sqlalchemy_history.utils.is_internal_column","text":"Return whether or not given column of given SQLAlchemy declarative classs is considered an internal column (a column whose purpose is mainly for SQLA-History's internal use). Parameters: version_obj \u2013 SQLAlchemy declarative class column_name \u2013 Name of the column model \u2013 Returns: \u2013 Bool sqlalchemy_history/utils.py def is_internal_column(model, column_name): \"\"\" Return whether or not given column of given SQLAlchemy declarative classs is considered an internal column (a column whose purpose is mainly for SQLA-History's internal use). :param version_obj: SQLAlchemy declarative class :param column_name: Name of the column :param model: :returns: Bool \"\"\" return column_name in ( option(model, \"transaction_column_name\"), option(model, \"end_transaction_column_name\"), option(model, \"operation_type_column_name\"), )","title":"is_internal_column()"},{"location":"utilities/#sqlalchemy_history.utils.is_modified","text":"Return whether or not the versioned properties of given object have been modified. Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 modified. sqlalchemy_history/utils.py def is_modified(obj): \"\"\" Return whether or not the versioned properties of given object have been modified. :param obj: SQLAlchemy declarative model object :returns: modified. \"\"\" column_names = sa.inspect(obj.__class__).columns.keys() versioned_column_keys = [prop.key for prop in versioned_column_properties(obj)] versioned_relationship_keys = [prop.key for prop in versioned_relationships(obj, versioned_column_keys)] for key, attr in sa.inspect(obj).attrs.items(): if key in column_names: if key not in versioned_column_keys: continue if attr.history.has_changes(): return True if key in versioned_relationship_keys: if attr.history.has_changes(): return True return False","title":"is_modified()"},{"location":"utilities/#sqlalchemy_history.utils.is_modified_or_deleted","text":"Return whether or not some of the versioned properties of given SQLAlchemy declarative object have been modified or if the object has been deleted. Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 Bool sqlalchemy_history/utils.py def is_modified_or_deleted(obj): \"\"\" Return whether or not some of the versioned properties of given SQLAlchemy declarative object have been modified or if the object has been deleted. :param obj: SQLAlchemy declarative model object :returns: Bool \"\"\" session = sa.orm.object_session(obj) return is_versioned(obj) and (is_modified(obj) or obj in chain(session.deleted, session.new))","title":"is_modified_or_deleted()"},{"location":"utilities/#sqlalchemy_history.utils.is_session_modified","text":"Return whether or not any of the versioned objects in given session have been either modified or deleted. Parameters: session \u2013 SQLAlchemy session object Returns: \u2013 Bool sqlalchemy_history/utils.py def is_session_modified(session): \"\"\"Return whether or not any of the versioned objects in given session have been either modified or deleted. :param session: SQLAlchemy session object :returns: Bool \"\"\" return any(is_modified_or_deleted(obj) for obj in versioned_objects(session))","title":"is_session_modified()"},{"location":"utilities/#sqlalchemy_history.utils.is_table_column","text":"Return wheter of not give field is a column over the database table. Parameters: column \u2013 SQLAclhemy model field Returns: \u2013 Bool sqlalchemy_history/utils.py def is_table_column(column): \"\"\" Return wheter of not give field is a column over the database table. :param column: SQLAclhemy model field :returns: Bool \"\"\" return isinstance(column, sa.Column)","title":"is_table_column()"},{"location":"utilities/#sqlalchemy_history.utils.is_versioned","text":"Return whether or not given object is versioned. Parameters: obj_or_class \u2013 SQLAlchemy \u2013 declarative model object or SQLAlchemy declarative model class \u2013 seealso \u2013 func Returns: \u2013 sqlalchemy_history/utils.py def is_versioned(obj_or_class): \"\"\" Return whether or not given object is versioned. :param obj_or_class: :param SQLAlchemy: declarative model object or SQLAlchemy declarative model :param class: :param seealso: func :returns: \"\"\" try: return hasattr(obj_or_class, \"__versioned__\") and get_versioning_manager(obj_or_class).option( obj_or_class, \"versioning\" ) except ClassNotVersioned: return False","title":"is_versioned()"},{"location":"utilities/#sqlalchemy_history.utils.option","text":"Return the option value of given option for given versioned object or class. Parameters: obj_or_class \u2013 SQLAlchemy declarative model object or class option_name \u2013 The name of an option to return sqlalchemy_history/utils.py def option(obj_or_class, option_name): \"\"\"Return the option value of given option for given versioned object or class. :param obj_or_class: SQLAlchemy declarative model object or class :param option_name: The name of an option to return \"\"\" if isinstance(obj_or_class, AliasedClass): obj_or_class = sa.inspect(obj_or_class).mapper.class_ cls = obj_or_class if isclass(obj_or_class) else obj_or_class.__class__ if not hasattr(cls, \"__versioned__\"): cls = parent_class(cls) return get_versioning_manager(cls).option(cls, option_name)","title":"option()"},{"location":"utilities/#sqlalchemy_history.utils.parent_class","text":"Return the parent class for given version model class. Parameters: model \u2013 SQLAlchemy declarative version model class version_cls \u2013 Returns: \u2013 sqlalchemy_history/utils.py def parent_class(version_cls): \"\"\" Return the parent class for given version model class. :param model: SQLAlchemy declarative version model class :param version_cls: :returns: \"\"\" manager = get_versioning_manager(version_cls) try: return next((k for k, v in manager.version_class_map.items() if v == version_cls)) except StopIteration: # Should raise Key Error if we can't find the parent_object of a orphaned versioned_model raise KeyError(version_cls)","title":"parent_class()"},{"location":"utilities/#sqlalchemy_history.utils.parent_table","text":"Return corresponding parent table for any given parent table. Parameters: version_table \u2013 A versioned table table which could be either association_table or model_table. sqlalchemy_history/utils.py def parent_table(version_table): \"\"\" Return corresponding parent table for any given parent table. :param version_table: A versioned table table which could be either association_table or model_table. \"\"\" manager = get_versioning_manager(version_table) try: return next((k for k, v in manager.version_table_map.items() if v == version_table)) except StopIteration: # Raise Key error as we couldn't find parent_object of versioned_object raise KeyError(version_table)","title":"parent_table()"},{"location":"utilities/#sqlalchemy_history.utils.transaction_class","text":"Return the associated transaction class for given versioned SQLAlchemy declarative class or version class. Parameters: cls \u2013 SQLAlchemy versioned declarative class or version model class Returns: \u2013 declarative class or version class. sqlalchemy_history/utils.py def transaction_class(cls): \"\"\" Return the associated transaction class for given versioned SQLAlchemy declarative class or version class. :param cls: SQLAlchemy versioned declarative class or version model class :returns: declarative class or version class. \"\"\" return get_versioning_manager(cls).transaction_cls","title":"transaction_class()"},{"location":"utilities/#sqlalchemy_history.utils.vacuum","text":"When making structural changes to version tables (for example dropping columns) there are sometimes situations where some old version records become futile. Vacuum deletes all futile version rows which had no changes compared to previous version. Parameters: session \u2013 SQLAlchemy session object model \u2013 SQLAlchemy declarative model class yield_per \u2013 how many rows to process at a time (Default value = 1000) sqlalchemy_history/utils.py def vacuum(session, model, yield_per=1000): \"\"\"When making structural changes to version tables (for example dropping columns) there are sometimes situations where some old version records become futile. Vacuum deletes all futile version rows which had no changes compared to previous version. :param session: SQLAlchemy session object :param model: SQLAlchemy declarative model class :param yield_per: how many rows to process at a time (Default value = 1000) \"\"\" version_cls = version_class(model) versions = defaultdict(list) query = (session.query(version_cls).order_by(option(version_cls, \"transaction_column_name\"))).yield_per( yield_per ) primary_key_col = sa.inspection.inspect(model).primary_key[0].name for version in query: version_id = getattr(version, primary_key_col) if versions[version_id]: prev_version = versions[version_id][-1] if naturally_equivalent(prev_version, version): session.delete(version) else: versions[version_id].append(version)","title":"vacuum()"},{"location":"utilities/#sqlalchemy_history.utils.version_class","text":"Return the version class for given SQLAlchemy declarative model class. Parameters: model \u2013 SQLAlchemy declarative model class Returns: \u2013 sqlalchemy_history/utils.py def version_class(model): \"\"\" Return the version class for given SQLAlchemy declarative model class. :param model: SQLAlchemy declarative model class :returns: \"\"\" manager = get_versioning_manager(model) return manager.version_class_map.get(model, None)","title":"version_class()"},{"location":"utilities/#sqlalchemy_history.utils.version_table","text":"Return associated version table for given SQLAlchemy Table object. Parameters: table \u2013 SQLAlchemy Table object sqlalchemy_history/utils.py def version_table(table): \"\"\" Return associated version table for given SQLAlchemy Table object. :param table: SQLAlchemy Table object \"\"\" manager = get_versioning_manager(table) return manager.version_table_map.get(table, None)","title":"version_table()"},{"location":"utilities/#sqlalchemy_history.utils.versioned_column_properties","text":"Parameters: obj \u2013 SQLAlchemy declarative model object obj_or_class \u2013 Returns: \u2013 declarative model object. sqlalchemy_history/utils.py def versioned_column_properties(obj_or_class): \"\"\" :param obj: SQLAlchemy declarative model object :param obj_or_class: :returns: declarative model object. \"\"\" manager = get_versioning_manager(obj_or_class) cls = obj_or_class if isclass(obj_or_class) else obj_or_class.__class__ mapper = sa.inspect(cls) for key, column in mapper.columns.items(): # Ignores non table columns if not is_table_column(column): continue if not manager.is_excluded_property(obj_or_class, key): yield getattr(mapper.attrs, key)","title":"versioned_column_properties()"},{"location":"utilities/#sqlalchemy_history.utils.versioned_objects","text":"Return all versioned objects in given session. Parameters: session \u2013 SQLAlchemy session object sqlalchemy_history/utils.py def versioned_objects(session): \"\"\" Return all versioned objects in given session. :param session: SQLAlchemy session object \"\"\" for obj in session: if is_versioned(obj): yield obj","title":"versioned_objects()"},{"location":"utilities/#sqlalchemy_history.utils.versioned_relationships","text":"Parameters: obj \u2013 SQLAlchemy declarative model object versioned_column_keys \u2013 Returns: \u2013 declarative model object. sqlalchemy_history/utils.py def versioned_relationships(obj, versioned_column_keys): \"\"\" :param obj: SQLAlchemy declarative model object :param versioned_column_keys: :returns: declarative model object. \"\"\" for prop in sa.inspect(obj.__class__).relationships: if any(c.key in versioned_column_keys for c in prop.local_columns): yield prop","title":"versioned_relationships()"},{"location":"utilities/#changeset","text":"Return a humanized changeset for given SQLAlchemy declarative object. With this function you can easily check the changeset of given object in current transaction. Parameters: obj \u2013 Returns: \u2013 this function you can easily check the changeset of given object in current transaction. sqlalchemy_history/utils.py def changeset(obj): \"\"\" Return a humanized changeset for given SQLAlchemy declarative object. With this function you can easily check the changeset of given object in current transaction. :param obj: :returns: this function you can easily check the changeset of given object in current transaction. \"\"\" data = {} session = sa.orm.object_session(obj) if session and obj in session.deleted: columns = [c for c in sa.inspect(obj.__class__).columns.values() if is_table_column(c)] for column in columns: if not column.primary_key: value = getattr(obj, column.key) if value is not None: data[column.key] = [None, getattr(obj, column.key)] else: for prop in obj.__mapper__.iterate_properties: history = get_history(obj, prop.key) if history.has_changes(): old_value = history.deleted[0] if history.deleted else None new_value = history.added[0] if history.added else None if new_value: data[prop.key] = [new_value, old_value] return data","title":"changeset"},{"location":"utilities/#count_versions","text":"Return the number of versions given object has. This function works even when obj has create_models and create_tables versioned settings Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 when obj has create_models and create_tables versioned settings disabled. sqlalchemy_history/utils.py def count_versions(obj): \"\"\" Return the number of versions given object has. This function works even when obj has `create_models` and `create_tables` versioned settings :param obj: SQLAlchemy declarative model object :returns: when obj has `create_models` and `create_tables` versioned settings disabled. \"\"\" session = sa.orm.object_session(obj) if session is None: # If object is transient, we assume it has no version history. return 0 manager = get_versioning_manager(obj) table_name = manager.option(obj, \"table_name\") % obj.__table__.name criteria = [\"%s = %r\" % (pk, getattr(obj, pk)) for pk in get_primary_keys(obj)] query = sa.text(\"SELECT COUNT(1) FROM %s WHERE %s\" % (table_name, \" AND \".join(criteria))) return session.execute(query).scalar()","title":"count_versions"},{"location":"utilities/#get_versioning_manager","text":"Return the associated SQLAlchemy-History VersioningManager for given SQLAlchemy declarative model class or object or table. Parameters: item \u2013 An item from SQLAlchemy A \u2013 declarative ORM object An \u2013 instance of a SQL table Returns: \u2013 SQLAlchemy declarative model class or object or table. sqlalchemy_history/utils.py def get_versioning_manager(item): \"\"\" Return the associated SQLAlchemy-History VersioningManager for given SQLAlchemy declarative model class or object or table. :param item: An item from SQLAlchemy :param A: declarative ORM object :param A: declarative ORM class :param An: instance of a SQL table :returns: SQLAlchemy declarative model class or object or table. \"\"\" # The ORM class or SQL table on which versioning was enabled versioned_item = None if isclass(item): versioned_item = item else: if isinstance(item, AliasedClass): versioned_item = sa.inspect(item).mapper.class_ elif isinstance(item, sa.Table): versioned_item = item else: versioned_item = item.__class__ try: return versioned_item.__versioning_manager__ except AttributeError: if isinstance(versioned_item, sa.Table): raise TableNotVersioned('Table \"%s\"' % versioned_item.name) else: raise ClassNotVersioned(versioned_item.__name__)","title":"get_versioning_manager"},{"location":"utilities/#is_modified","text":"Return whether or not the versioned properties of given object have been modified. Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 modified. sqlalchemy_history/utils.py def is_modified(obj): \"\"\" Return whether or not the versioned properties of given object have been modified. :param obj: SQLAlchemy declarative model object :returns: modified. \"\"\" column_names = sa.inspect(obj.__class__).columns.keys() versioned_column_keys = [prop.key for prop in versioned_column_properties(obj)] versioned_relationship_keys = [prop.key for prop in versioned_relationships(obj, versioned_column_keys)] for key, attr in sa.inspect(obj).attrs.items(): if key in column_names: if key not in versioned_column_keys: continue if attr.history.has_changes(): return True if key in versioned_relationship_keys: if attr.history.has_changes(): return True return False","title":"is_modified"},{"location":"utilities/#is_modified_or_deleted","text":"Return whether or not some of the versioned properties of given SQLAlchemy declarative object have been modified or if the object has been deleted. Parameters: obj \u2013 SQLAlchemy declarative model object Returns: \u2013 Bool sqlalchemy_history/utils.py def is_modified_or_deleted(obj): \"\"\" Return whether or not some of the versioned properties of given SQLAlchemy declarative object have been modified or if the object has been deleted. :param obj: SQLAlchemy declarative model object :returns: Bool \"\"\" session = sa.orm.object_session(obj) return is_versioned(obj) and (is_modified(obj) or obj in chain(session.deleted, session.new))","title":"is_modified_or_deleted"},{"location":"utilities/#is_session_modified","text":"Return whether or not any of the versioned objects in given session have been either modified or deleted. Parameters: session \u2013 SQLAlchemy session object Returns: \u2013 Bool sqlalchemy_history/utils.py def is_session_modified(session): \"\"\"Return whether or not any of the versioned objects in given session have been either modified or deleted. :param session: SQLAlchemy session object :returns: Bool \"\"\" return any(is_modified_or_deleted(obj) for obj in versioned_objects(session))","title":"is_session_modified"},{"location":"utilities/#is_versioned","text":"Return whether or not given object is versioned. Parameters: obj_or_class \u2013 SQLAlchemy \u2013 declarative model object or SQLAlchemy declarative model class \u2013 seealso \u2013 func Returns: \u2013 sqlalchemy_history/utils.py def is_versioned(obj_or_class): \"\"\" Return whether or not given object is versioned. :param obj_or_class: :param SQLAlchemy: declarative model object or SQLAlchemy declarative model :param class: :param seealso: func :returns: \"\"\" try: return hasattr(obj_or_class, \"__versioned__\") and get_versioning_manager(obj_or_class).option( obj_or_class, \"versioning\" ) except ClassNotVersioned: return False","title":"is_versioned"},{"location":"utilities/#parent_class","text":"Return the parent class for given version model class. Parameters: model \u2013 SQLAlchemy declarative version model class version_cls \u2013 Returns: \u2013 sqlalchemy_history/utils.py def parent_class(version_cls): \"\"\" Return the parent class for given version model class. :param model: SQLAlchemy declarative version model class :param version_cls: :returns: \"\"\" manager = get_versioning_manager(version_cls) try: return next((k for k, v in manager.version_class_map.items() if v == version_cls)) except StopIteration: # Should raise Key Error if we can't find the parent_object of a orphaned versioned_model raise KeyError(version_cls)","title":"parent_class"},{"location":"utilities/#transaction_class","text":"Return the associated transaction class for given versioned SQLAlchemy declarative class or version class. Parameters: cls \u2013 SQLAlchemy versioned declarative class or version model class Returns: \u2013 declarative class or version class. sqlalchemy_history/utils.py def transaction_class(cls): \"\"\" Return the associated transaction class for given versioned SQLAlchemy declarative class or version class. :param cls: SQLAlchemy versioned declarative class or version model class :returns: declarative class or version class. \"\"\" return get_versioning_manager(cls).transaction_cls","title":"transaction_class"},{"location":"utilities/#version_class","text":"Return the version class for given SQLAlchemy declarative model class. Parameters: model \u2013 SQLAlchemy declarative model class Returns: \u2013 sqlalchemy_history/utils.py def version_class(model): \"\"\" Return the version class for given SQLAlchemy declarative model class. :param model: SQLAlchemy declarative model class :returns: \"\"\" manager = get_versioning_manager(model) return manager.version_class_map.get(model, None)","title":"version_class"},{"location":"utilities/#versioned_objects","text":"Return all versioned objects in given session. Parameters: session \u2013 SQLAlchemy session object sqlalchemy_history/utils.py def versioned_objects(session): \"\"\" Return all versioned objects in given session. :param session: SQLAlchemy session object \"\"\" for obj in session: if is_versioned(obj): yield obj","title":"versioned_objects"},{"location":"utilities/#version_table","text":"Return associated version table for given SQLAlchemy Table object. Parameters: table \u2013 SQLAlchemy Table object sqlalchemy_history/utils.py def version_table(table): \"\"\" Return associated version table for given SQLAlchemy Table object. :param table: SQLAlchemy Table object \"\"\" manager = get_versioning_manager(table) return manager.version_table_map.get(table, None)","title":"version_table"},{"location":"version_objects/","text":"Version objects Operation types When changing entities and committing results into database SQLA-History saves the used operations (INSERT, UPDATE or DELETE) into version entities. The operation types are stored by default to a small integer field named 'operation_type'. Class called 'Operation' holds convenient constants for these values as shown below: >>> from sqlalchemy_history import Operation >>> article = Article(name=u'Some article') >>> session.add(article) >>> session.commit() >>> article.versions[0].operation_type == Operation.INSERT >>> article.name = u'Some updated article' >>> session.commit() >>> article.versions[1].operation_type == Operation.UPDATE >>> session.delete(article) >>> session.commit() >>> article.versions[2].operation_type == Operation.DELETE Version traversal >>> first_version = article.versions[0] >>> first_version.index >>> second_version = first_version.next >>> assert second_version == article.versions[1] >>> second_version.previous == first_version True >>> second_version.index 1 Changeset SQLA-History provides easy way for getting the changeset of given version object. Each version contains a changeset property which holds a dict of changed fields in that version. >>> article = Article(name=u'New article', content=u'Some content') >>> session.add(article) >>> session.commit(article) >>> version = article.versions[0] >>> version.changeset { 'id': [None, 1], 'name': [None, u'New article'], 'content': [None, u'Some content'] } >>> article.name = u'Updated article' >>> session.commit() >>> version = article.versions[1] >>> version.changeset { 'name': [u'New article', u'Updated article'], } >>> session.delete(article) >>> version = article.versions[1] >>> version.changeset { 'id': [1, None] 'name': [u'Updated article', None], 'content': [u'Some content', None] } SQLAlchemy-History also provides a utility function called changeset. With this function you can easily check the changeset of given object in current transaction. >>> from sqlalchemy_history import changeset >>> article = Article(name=u'Some article') >>> changeset(article) {'name': [None, u'Some article']} Version relationships Each version object reflects all parent object relationships. You can think version object relations as 'relations of parent object in given point in time'. Lets say you have two models: Article and Category. Each Article has one Category. In the following example we first add article and category objects into database. SQLA-History saves new ArticleVersion and CategoryVersion records in the background. After that we update the created article entity to use another category. SQLA-History creates new version objects accordingly. Lastly we check the category relations of different article versions. >>> category = Category(name=u'Some category') >>> article = Article( ... name=u'Some article', ... category=category ... ) >>> session.add(article) >>> session.commit() >>> article.category = Category(name=u'Some other category') >>> session.commit() >>> article.versions[0].category.name # u'Some category' >>> article.versions[1].category.name # u'Some other category' The logic how SQLAlchemy-History builds these relationships is within the RelationshipBuilder class. Relationships to non-versioned classes Let's take previous example of Articles and Categories. Now consider that only Article model is versioned: >>> class Article(Base): ... __tablename__ = 'article' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255), nullable=False) >>> class Category(Base): ... __tablename__ = 'tag' ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255)) ... article_id = sa.Column(sa.Integer, sa.ForeignKey(Article.id)) ... article = sa.orm.relationship( ... Article, ... backref=sa.orm.backref('categories') ... ) Here Article versions will still reflect the relationships of Article model but they will simply return Category objects instead of CategoryVersion objects: >>> category = Category(name=u'Some category') >>> article = Article( ... name=u'Some article', ... category=category ... ) >>> session.add(article) >>> session.commit() >>> article.category = Category(name=u'Some other category') >>> session.commit() >>> version = article.versions[0] >>> version.category.name 'Some other category' >>> isinstance(version.category, Category) True Dynamic relationships If the parent class has a dynamic relationship it will be reflected as a property which returns a query in the associated version class. >>> class Article(Base): ... __tablename__ = 'article' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255), nullable=False) >>> class Tag(Base): ... __tablename__ = 'tag' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255)) ... article_id = sa.Column(sa.Integer, sa.ForeignKey(Article.id)) ... article = sa.orm.relationship( ... Article, ... backref=sa.orm.backref( ... 'tags', ... lazy='dynamic' ... ) ... ) >>> article = Article() >>> article.name = u'Some article' >>> article.content = u'Some content' >>> session.add(article) >>> session.commit() >>> tag_query = article.versions[0].tags >>> tag_query.all() # return all tags for given version >>> tag_query.count() # return the tag count for given version","title":"Version objects"},{"location":"version_objects/#version-objects","text":"","title":"Version objects"},{"location":"version_objects/#operation-types","text":"When changing entities and committing results into database SQLA-History saves the used operations (INSERT, UPDATE or DELETE) into version entities. The operation types are stored by default to a small integer field named 'operation_type'. Class called 'Operation' holds convenient constants for these values as shown below: >>> from sqlalchemy_history import Operation >>> article = Article(name=u'Some article') >>> session.add(article) >>> session.commit() >>> article.versions[0].operation_type == Operation.INSERT >>> article.name = u'Some updated article' >>> session.commit() >>> article.versions[1].operation_type == Operation.UPDATE >>> session.delete(article) >>> session.commit() >>> article.versions[2].operation_type == Operation.DELETE","title":"Operation types"},{"location":"version_objects/#version-traversal","text":">>> first_version = article.versions[0] >>> first_version.index >>> second_version = first_version.next >>> assert second_version == article.versions[1] >>> second_version.previous == first_version True >>> second_version.index 1","title":"Version traversal"},{"location":"version_objects/#changeset","text":"SQLA-History provides easy way for getting the changeset of given version object. Each version contains a changeset property which holds a dict of changed fields in that version. >>> article = Article(name=u'New article', content=u'Some content') >>> session.add(article) >>> session.commit(article) >>> version = article.versions[0] >>> version.changeset { 'id': [None, 1], 'name': [None, u'New article'], 'content': [None, u'Some content'] } >>> article.name = u'Updated article' >>> session.commit() >>> version = article.versions[1] >>> version.changeset { 'name': [u'New article', u'Updated article'], } >>> session.delete(article) >>> version = article.versions[1] >>> version.changeset { 'id': [1, None] 'name': [u'Updated article', None], 'content': [u'Some content', None] } SQLAlchemy-History also provides a utility function called changeset. With this function you can easily check the changeset of given object in current transaction. >>> from sqlalchemy_history import changeset >>> article = Article(name=u'Some article') >>> changeset(article) {'name': [None, u'Some article']}","title":"Changeset"},{"location":"version_objects/#version-relationships","text":"Each version object reflects all parent object relationships. You can think version object relations as 'relations of parent object in given point in time'. Lets say you have two models: Article and Category. Each Article has one Category. In the following example we first add article and category objects into database. SQLA-History saves new ArticleVersion and CategoryVersion records in the background. After that we update the created article entity to use another category. SQLA-History creates new version objects accordingly. Lastly we check the category relations of different article versions. >>> category = Category(name=u'Some category') >>> article = Article( ... name=u'Some article', ... category=category ... ) >>> session.add(article) >>> session.commit() >>> article.category = Category(name=u'Some other category') >>> session.commit() >>> article.versions[0].category.name # u'Some category' >>> article.versions[1].category.name # u'Some other category' The logic how SQLAlchemy-History builds these relationships is within the RelationshipBuilder class.","title":"Version relationships"},{"location":"version_objects/#relationships-to-non-versioned-classes","text":"Let's take previous example of Articles and Categories. Now consider that only Article model is versioned: >>> class Article(Base): ... __tablename__ = 'article' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255), nullable=False) >>> class Category(Base): ... __tablename__ = 'tag' ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255)) ... article_id = sa.Column(sa.Integer, sa.ForeignKey(Article.id)) ... article = sa.orm.relationship( ... Article, ... backref=sa.orm.backref('categories') ... ) Here Article versions will still reflect the relationships of Article model but they will simply return Category objects instead of CategoryVersion objects: >>> category = Category(name=u'Some category') >>> article = Article( ... name=u'Some article', ... category=category ... ) >>> session.add(article) >>> session.commit() >>> article.category = Category(name=u'Some other category') >>> session.commit() >>> version = article.versions[0] >>> version.category.name 'Some other category' >>> isinstance(version.category, Category) True","title":"Relationships to non-versioned classes"},{"location":"version_objects/#dynamic-relationships","text":"If the parent class has a dynamic relationship it will be reflected as a property which returns a query in the associated version class. >>> class Article(Base): ... __tablename__ = 'article' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255), nullable=False) >>> class Tag(Base): ... __tablename__ = 'tag' ... __versioned__ = {} ... id = sa.Column(sa.Integer, autoincrement=True, primary_key=True) ... name = sa.Column(sa.Unicode(255)) ... article_id = sa.Column(sa.Integer, sa.ForeignKey(Article.id)) ... article = sa.orm.relationship( ... Article, ... backref=sa.orm.backref( ... 'tags', ... lazy='dynamic' ... ) ... ) >>> article = Article() >>> article.name = u'Some article' >>> article.content = u'Some content' >>> session.add(article) >>> session.commit() >>> tag_query = article.versions[0].tags >>> tag_query.all() # return all tags for given version >>> tag_query.count() # return the tag count for given version","title":"Dynamic relationships"}]}